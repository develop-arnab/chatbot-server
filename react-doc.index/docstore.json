[["0",{"pageContent":"What is React?\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-01/post.md)\n\nToday, we're starting out at the beginning. Let's look at what\nReact is and what makes it tick. We'll discuss why we want to\nuse it.\nOver the next 30 days, you'll get a good feel for the various parts of the React\n(https://facebook.github.io/react/) web framework and its ecosystem.\nEach day in our 30 day adventure will build upon the previous day's materials,\nso by the end of the series, you'll not only know the terms, concepts, and\nunderpinnings of how the framework works, but be able to use React in your\nnext web application.\nLet's get started. We'll start at the very beginning\n(https://www.youtube.com/watch?v=1RW3nDRmu6k) as it's a very good\nplace to start.","metadata":{"loc":{"lines":{"from":1,"to":15}}}}],["1",{"pageContent":"What is React?\nReact (https://facebook.github.io/react/) is a JavaScript library for building\nuser interfaces. It is the view layer for web applications.\nAt the heart of all React applications are components. A component is a selfcontained module that renders some output. We can write interface\nelements like a button or an input field as a React component. Components\n1","metadata":{"loc":{"lines":{"from":17,"to":22}}}}],["2",{"pageContent":"are composable. A component might include one or more other components\nin its output.\nBroadly speaking, to write React apps we write React components that\ncorrespond to various interface elements. We then organize these\ncomponents inside higher-level components which define the structure of\nour application.\nFor example, take a form. A form might consist of many interface elements,\nlike input fields, labels, or buttons. Each element inside the form can be\nwritten as a React component. We'd then write a higher-level component,\nthe form component itself. The form component would specify the structure\nof the form and include each of these interface elements inside of it.\nImportantly, each component in a React app abides by strict data\nmanagement principles. Complex, interactive user interfaces often involve\ncomplex data and application state. The surface area of React is limited and\naimed at giving us the tools to be able to anticipate how our application will","metadata":{"loc":{"lines":{"from":24,"to":38}}}}],["3",{"pageContent":"complex data and application state. The surface area of React is limited and\naimed at giving us the tools to be able to anticipate how our application will\nlook with a given set of circumstances. We dig into these principles later in\nthe course.","metadata":{"loc":{"lines":{"from":38,"to":41}}}}],["4",{"pageContent":"Okay, so how do we use it?\nReact is a JavaScript framework. Using the framework is as simple as\nincluding a JavaScript file in our HTML and using the React exports in our\napplication's JavaScript.\nFor instance, the Hello world example of a React website can be as simple as:\n\n2\n\n\f<html>\n<head>\n<meta charset=\"utf-8\">\n<title>Hello world</title>\n<!-- Script tags including React -->\n<script\nsrc=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.1/react.min.js\"\n></script>\n<script\nsrc=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.1/reactdom.min.js\"></script>\n<script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\">\n</script>\n</head>\n<body>\n<div id=\"app\"></div>\n<script type=\"text/babel\">\nReactDOM.render(\n<h1>Hello world</h1>,\ndocument.querySelector('#app')\n);\n</script>\n</body>\n</html>","metadata":{"loc":{"lines":{"from":43,"to":73}}}}],["5",{"pageContent":"Although it might look a little scary, the JavaScript code is a single line that\ndynamically adds Hello world to the page. Note that we only needed to\ninclude a handful of JavaScript files to get everything working.\n\nHow does it work?\nUnlike many of its predecessors, React operates not directly on the browser's\nDocument Object Model (DOM) immediately, but on a virtual DOM. That is,\nrather than manipulating the document in a browser after changes to our\ndata (which can be quite slow) it resolves changes on a DOM built and run\nentirely in memory. After the virtual DOM has been updated, React\nintelligently determines what changes to make to the actual browser's DOM.\n\n3","metadata":{"loc":{"lines":{"from":75,"to":87}}}}],["6",{"pageContent":"3\n\n\fThe React Virtual DOM (https://facebook.github.io/react/docs/domdifferences.html) exists entirely in-memory and is a representation of the\nweb browser's DOM. Because of this, when we write a React component,\nwe're not writing directly to the DOM, but we're writing a virtual component\nthat React will turn into the DOM.\nIn the next article, we'll look at what this means for us as we build our React\ncomponents and jump into JSX and writing our first real components.\n\n4\n\n\fWhat is JSX?\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-02/post.md)\n\nNow that we know what React is, let's take a look at a few terms\nand concepts that will come up throughout the rest of the\nseries.\nIn our previous article, we looked at what React\n(https://facebook.github.io/react/) is and discussed at a high-level how it\nworks. In this article, we're going to look at one part of the React ecosystem:\nES6 and JSX.","metadata":{"loc":{"lines":{"from":87,"to":107}}}}],["7",{"pageContent":"JSX/ES5/ES6 WTF??!\nIn any cursory search on the Internet looking for React material, no doubt\nyou have already run into the terms JSX , ES5, and ES6. These opaque\nacronyms can get confusing quickly.\nES5 (the ES stands for ECMAScript) is basically \"regular JavaScript.\" The 5th\nupdate to JavaScript, ES5 was finalized in 2009. It has been supported by all\nmajor browsers for several years. Therefore, if you've written or seen any\nJavaScript in the recent past, chances are it was ES5.\nES6 is a new version of JavaScript that adds some nice syntactical and\nfunctional additions. It was finalized in 2015. ES6 is almost fully supported\n(http://kangax.github.io/compat-table/es6/) by all major browsers. But it\n\n5","metadata":{"loc":{"lines":{"from":109,"to":121}}}}],["8",{"pageContent":"5\n\n\fwill be some time until older versions of web browsers are phased out of use.\nFor instance, Internet Explorer 11 does not support ES6, but has about 12% of\nthe browser market share.\nIn order to reap the benefits of ES6 today, we have to do a few things to get it\nto work in as many browsers as we can:\n1. We have to transpile our code so that a wider range of browsers\nunderstand our JavaScript. This means converting ES6 JavaScript into\nES5 JavaScript.\n2. We have to include a shim or polyfill that provides additional\nfunctionality added in ES6 that a browser may or may not have.\nWe'll see how we do this a bit later in the series.\n\nMost of the code we'll write in this series will be easily\ntranslatable to ES5. In cases where we use ES6, we'll\nintroduce the feature at first and then walk through it.","metadata":{"loc":{"lines":{"from":121,"to":137}}}}],["9",{"pageContent":"Most of the code we'll write in this series will be easily\ntranslatable to ES5. In cases where we use ES6, we'll\nintroduce the feature at first and then walk through it.\n\nAs we'll see, all of our React components have a render function that\nspecifies what the HTML output of our React component will be. JavaScript\neXtension, or more commonly JSX, is a React extension that allows us to\nwrite JavaScript that looks like HTML.\n\nAlthough in previous paradigms it was viewed as a bad habit\nto include JavaScript and markup in the same place, it turns\nout that combining the view with the functionality makes\nreasoning about the view straight-forward.\n\n6\n\n\fTo see what this means, imagine we had a React component that renders an\nh1 HTML tag. JSX allows us to declare this element in a manner that closely\nresembles HTML:\n\nclass HelloWorld extends React.Component {\nrender() {\nreturn (\n<h1 className='large'>Hello World</h1>\n);\n}\n}","metadata":{"loc":{"lines":{"from":137,"to":163}}}}],["10",{"pageContent":"class HelloWorld extends React.Component {\nrender() {\nreturn (\n<h1 className='large'>Hello World</h1>\n);\n}\n}\n\nHello World\nThe render() function in the HelloWorld component looks like it's returning\nHTML, but this is actually JSX. The JSX is translated to regular JavaScript at\nruntime. That component, after translation, looks like this:\n\nclass HelloWorld extends React.Component {\nrender() {\nreturn (\nReact.createElement(\n'h1',\n{className: 'large'},\n'Hello World'\n)\n);\n}\n}\n\nWhile JSX looks like HTML, it is actually just a terser way to write a\nReact.createElement() declaration. When a component renders, it outputs a\ntree of React elements or a virtual representation of the HTML elements this\ncomponent outputs. React will then determine what changes to make to the\nactual DOM based on this React element representation. In the case of the\nHelloWorld component, the HTML that React writes to the DOM will look\n\nlike this:\n7\n\n\f<h1 class='large'>Hello World</h1>","metadata":{"loc":{"lines":{"from":163,"to":198}}}}],["11",{"pageContent":"like this:\n7\n\n\f<h1 class='large'>Hello World</h1>\n\nThe class extends syntax we used in our first React\ncomponent is ES6 syntax. It allows us to write objects using a\nfamiliar Object-Oriented style. In ES5, the class syntax\nmight be translated as:\nvar HelloWorld = function() {}\nObject.extends(HelloWorld, React.Component)\nHelloWorld.prototype.render = function() {}","metadata":{"loc":{"lines":{"from":198,"to":209}}}}],["12",{"pageContent":"Because JSX is JavaScript, we can't use JavaScript reserved words. This\nincludes words like class and for .\nReact gives us the attribute className . We use it in HelloWorld to set the\nlarge class on our h1 tag. There are a few other attributes, such as the for\nattribute on a label that React translates into htmlFor as for is also a\nreserved word. We'll look at these when we start using them.\nIf we want to write pure JavaScript instead of rely on a JSX compiler, we can\njust write the React.createElement() function and not worry about the layer\nof abstraction. But we like JSX. It's especially more readable with complex\ncomponents. Consider the following JSX:\n\n<div>\n<img src=\"profile.jpg\" alt=\"Profile photo\" />\n<h1>Welcome back Ari</h1>\n</div>\n\nThe JavaScript delivered to the browser will look like this:\n\n8\n\n\fReact.createElement(\"div\", null,\nReact.createElement(\"img\", {src: \"profile.jpg\", alt: \"Profile\nphoto\"}),\nReact.createElement(\"h1\", null, \"Welcome back Ari\")\n);","metadata":{"loc":{"lines":{"from":211,"to":235}}}}],["13",{"pageContent":"8\n\n\fReact.createElement(\"div\", null,\nReact.createElement(\"img\", {src: \"profile.jpg\", alt: \"Profile\nphoto\"}),\nReact.createElement(\"h1\", null, \"Welcome back Ari\")\n);\n\nAgain, while you can skip JSX and write the latter directly, the JSX syntax is\nwell-suited for representing nested HTML elements.\nNow that we understand JSX, we can start writing our first React\ncomponents. Join us tomorrow when we jump into our first React app.\n\n9\n\n\fOur First Components\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-03/post.md)\n\nThe first two articles in this series were heavy on discussion. In\ntoday's session, let's dive into some code and write our first\nReact app.\nLet's revisit the \"Hello world\" app we introduced on day one. Here it is again,\nwritten slightly differently:\n\n10","metadata":{"loc":{"lines":{"from":235,"to":259}}}}],["14",{"pageContent":"10\n\n\f<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>Hello world</title>\n<!-- Script tags including React -->\n<script\nsrc=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.1/react.min.js\"\n></script>\n<script\nsrc=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.1/reactdom.min.js\"></script>\n<script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\">\n</script>\n</head>\n<body>\n<div id=\"app\"></div>\n<script type=\"text/babel\">\nvar app = <h1>Hello world</h1>\nvar mountComponent = document.querySelector('#app');\nReactDOM.render(app, mountComponent);\n</script>\n</body>\n</html>\n\nHello world\nLoading the React library\nWe've included the source of React as a <script> tag inside the <head>\nelement of our page. It's important to place our <script> loading tags before\nwe start writing our React application otherwise the React and ReactDOM\nvariables won't be defined in time for us to use them.\nAlso inside head is a script tag that includes a library, babel-core . But what\nis babel-core ?","metadata":{"loc":{"lines":{"from":259,"to":292}}}}],["15",{"pageContent":"Babel\n11\n\n\fYesterday, we talked about ES5 and ES6. We mentioned that support for ES6\nis still spotty. In order to use ES6, it's best if we transpile our ES6 JavaScript\ninto ES5 JavaScript to support more browsers.\nBabel is a library for transpiling ES6 to ES5.\nInside body , we have a script body. Inside of script , we define our first\nReact application. Note that the script tag has a type of text/babel :\n\n<script type=\"text/babel\">\n\nThis signals to Babel that we would like it to handle the execution of the\nJavaScript inside this script body, this way we can write our React app using\nES6 JavaScript and be assured that Babel will live-transpile its execution in\nbrowsers that only support ES5.\n\nWarning in the console?\nWhen using the babel-standalone package, we'll get a warning in the\nconsole. This is fine and expected. We'll switch to a precompilation step in\na few days.\nWe've included the <script /> tag here for ease of use.","metadata":{"loc":{"lines":{"from":294,"to":315}}}}],["16",{"pageContent":"The React app\nInside the Babel script body, we've defined our first React application. Our\napplication consists of a single element, the <h1>Hello world</h1> . The call\nto ReactDOM.render() actually places our tiny React application on the page.\nWithout the call to ReactDOM.render() , nothing would render in the DOM.\nThe first argument to ReactDOM.render() is what to render and the second is\nwhere:\n12\n\n\fReactDOM.render(<what>, <where>)\n\nWe've written a React application. Our \"app\" is a React element which\nrepresents an h1 tag. But this isn't very interesting. Rich web applications\naccept user input, change their shape based on user interaction, and\ncommunicate with web servers. Let's begin touching on this power by\nbuilding our first React component.","metadata":{"loc":{"lines":{"from":317,"to":332}}}}],["17",{"pageContent":"Components and more\nWe mentioned at the beginning of this series that at the heart of all React\napplications are components. The best way to understand React components\nis to write them. We'll write our React components as ES6 classes.\nLet's look at a component we'll call App . Like all other React components, this\nES6 class will extend the React.Component class from the React package:\n\nclass App extends React.Component {\nrender() {\nreturn <h1>Hello from our app</h1>\n}\n}\n\nAll React components require at least a render() function.\nThis render() function is expected to return a virtual DOM\nrepresentation of the browser DOM element(s).\n\nIn our index.html , let's replace our JavaScript from before with our new App\ncomponent.\n\n13","metadata":{"loc":{"lines":{"from":334,"to":354}}}}],["18",{"pageContent":"In our index.html , let's replace our JavaScript from before with our new App\ncomponent.\n\n13\n\n\f<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>Hello world</title>\n<!-- Script tags including React -->\n<script\nsrc=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.1/react.min.js\"\n></script>\n<script\nsrc=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.1/reactdom.min.js\"></script>\n<script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\">\n</script>\n</head>\n<body>\n<div id=\"app\"></div>\n<script type=\"text/babel\">\nclass App extends React.Component {\nrender() {\nreturn <h1>Hello from our app</h1>\n}\n}\n</script>\n</body>\n</html>\n\nHowever, nothing is going to render on the screen. Do you remember why?\nWe haven't told React we want to render anything on the screen or where to\nrender it. We need to use the ReactDOM.render() function again to express to\nReact what we want rendered and where.\nAdding the ReactDOM.render() function will render our application on screen:","metadata":{"loc":{"lines":{"from":354,"to":389}}}}],["19",{"pageContent":"var mount = document.querySelector('#app');\nReactDOM.render(<App />, mount);\n\nHello from our app\n\n14\n\n\fHello from our app\n\nNotice that we can render our React app using the App class as though it is a\nbuilt-in DOM component type (like the <h1 /> and <div /> tags). Here we're\nusing it as though it's an element with the angle brackets: <App /> .\nThe idea that our React components act just like any other element on our\npage allows us to build a component tree just as if we were creating a native\nbrowser tree.\nWhile we're rendering a React component now, our app still lacks richness or\ninteractivity. Soon, we'll see how to make React components data-driven and\ndynamic.\nBut first, in the next installment of this series, we'll explore how we can layer\ncomponents. Nested components are the foundation of a rich React web\napplication.\n\n15\n\n\fComplex Components\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-04/post.md)","metadata":{"loc":{"lines":{"from":391,"to":416}}}}],["20",{"pageContent":"15\n\n\fComplex Components\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-04/post.md)\n\nAwesome, we've built our first component. Now let's get a bit\nfancier and start building a more complex interface.\nIn the previous section of 30 Days of React, we started building our first React\ncomponent. In this section, we'll continue our work with our App component\nand start building a more complex UI.\nA common web element we might see is a user timeline. For instance, we\nmight have an application that shows a history of events happening such as\napplications like Facebook and Twitter.\n\n16","metadata":{"loc":{"lines":{"from":416,"to":430}}}}],["21",{"pageContent":"16\n\n\fStyles\nAs we're not focusing on CSS\n(https://www.w3.org/standards/webdesign/htmlcss) in this course,\nwe're not covering the CSS specific to build the timeline as you see it on\nthe screen.\nHowever, we want to make sure the timeline you build looks similar to\nours. If you include the following CSS as a <link /> tag in your code, your\ntimeline will look similar and will be using the same styling ours is using:","metadata":{"loc":{"lines":{"from":430,"to":439}}}}],["22",{"pageContent":"<link\nhref=\"https://cdn.jsdelivr.net/gh/fullstackreact/30-days-ofreact@master/day-04/src/components/Timeline/Timeline.css\"\nrel=\"stylesheet\"\ntype=\"text/css\"\n/>\nAnd make sure to surround your code in a component with the class of\ndemo (we left it this way purposefully as it's the exact same code we use in\nall the demos here). Check out the\nhttps://jsfiddle.net/auser/zwomnfwk/\n(https://jsfiddle.net/auser/zwomnfwk/) for a working example.\nThe entire compiled CSS can be found on the github repository at\nhttps://github.com/fullstackreact/30-days-of-react/blob/master/day04/src/components/Timeline/Timeline.css\n(https://github.com/fullstackreact/30-days-of-react/blob/master/day04/src/components/Timeline/Timeline.css).\nIn addition, in order to make the timeline look exactly like the way ours\ndoes on the site, you'll need to include font-awesome\n(http://fontawesome.io/) in your web application. There are multiple\nways to handle this. The simplest way is to include the link styles:\n\n17","metadata":{"loc":{"lines":{"from":441,"to":459}}}}],["23",{"pageContent":"17\n\n\f<link\nhref=\"https://maxcdn.bootstrapcdn.com/fontawesome/4.7.0/css/font-awesome.min.css\"\nrel=\"stylesheet\"\ntype=\"text/css\"\n/>\n\nAll the code for the examples on the page is available at the github repo\n(at https://github.com/fullstackreact/30-days-of-react)\n(https://github.com/fullstackreact/30-days-of-react).\n\nWe could build this entire UI in a single component. However, building an\nentire application in a single component is not a great idea as it can grow\nhuge, complex, and difficult to test.\n\n18","metadata":{"loc":{"lines":{"from":459,"to":475}}}}],["24",{"pageContent":"We could build this entire UI in a single component. However, building an\nentire application in a single component is not a great idea as it can grow\nhuge, complex, and difficult to test.\n\n18\n\n\fclass Timeline extends React.Component {\nrender() {\nreturn (\n<div className=\"notificationsFrame\">\n<div className=\"panel\">\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">Timeline</span>\n<input\ntype=\"text\"\nclassName=\"searchInput\"\nplaceholder=\"Search ...\" />\n<div className=\"fa fa-search searchIcon\"></div>\n</div>\n<div className=\"content\">\n<div className=\"line\"></div>\n<div className=\"item\">\n<div className=\"avatar\">\n<img\nalt='doug'\nsrc=\"http://www.croop.cl/UI/twitter/images/doug.jpg\"\n/>\n</div>\n<span className=\"time\">\nAn hour ago\n</span>\n<p>Ate lunch</p>\n</div>\n<div className=\"item\">\n<div className=\"avatar\">\n<img\n19","metadata":{"loc":{"lines":{"from":475,"to":516}}}}],["25",{"pageContent":"alt='doug'\nsrc=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" />\n</div>\n<span className=\"time\">10 am</span>\n<p>Read Day two article</p>\n</div>\n<div className=\"item\">\n<div className=\"avatar\">\n<img\nalt='doug'\nsrc=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" />\n</div>\n<span className=\"time\">10 am</span>\n<p>Lorem Ipsum is simply dummy text of the printing and\ntypesetting industry.</p>\n</div>\n<div className=\"item\">\n<div className=\"avatar\">\n<img\nalt='doug'\nsrc=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" />\n</div>\n<span className=\"time\">2:21 pm</span>\n<p>Lorem Ipsum has been the industry's standard dummy\ntext ever since the 1500s, when an unknown printer took a galley of\ntype and scrambled it to make a type specimen book.</p>\n</div>\n</div>\n</div>\n</div>\n)\n}\n}\n\n20\n\n\fTimeline\n\n\n\nAn hour ago\n\nAte lunch\n10 am\n\nRead Day two article\n10 am\n\nLorem Ipsum is simply dummy text of the printing and\ntypesetting industry.\n2:21 pm","metadata":{"loc":{"lines":{"from":518,"to":568}}}}],["26",{"pageContent":"20\n\n\fTimeline\n\n\n\nAn hour ago\n\nAte lunch\n10 am\n\nRead Day two article\n10 am\n\nLorem Ipsum is simply dummy text of the printing and\ntypesetting industry.\n2:21 pm\n\nLorem Ipsum has been the industry's standard dummy\ntext ever since the 1500s, when an unknown printer\ntook a galley of type and scrambled it to make a type\nspecimen book.\n\nBreaking it down\nRather than build this in a single component, let's break it down into multiple\ncomponents.\nLooking at this component, there are 2 separate parts to the larger\ncomponent as a whole:\n1. The title bar\n2. The content\n\n21\n\n\fWe can chop up the content part of the component into individual places of\nconcern. There are 3 different item components inside the content part.\n\n22","metadata":{"loc":{"lines":{"from":568,"to":604}}}}],["27",{"pageContent":"21\n\n\fWe can chop up the content part of the component into individual places of\nconcern. There are 3 different item components inside the content part.\n\n22\n\n\fIf we wanted to go one step further, we could even break\ndown the title bar into 3 component parts, the menu button,\nthe title, and the search icon. We could dive even further into\neach one of those if we needed to.\nDeciding how deep to split your components is more of an art than a\nscience and is a skill you'll develop with experience.\n\nIn any case, it's usually a good idea to start looking at applications using the\nidea of components. By breaking our app down into components it becomes\neasier to test and easier to keep track of what functionality goes where.","metadata":{"loc":{"lines":{"from":604,"to":620}}}}],["28",{"pageContent":"The container component\nTo build our notifications app, let's start by building the container to hold the\nentire app. Our container is simply going to be a wrapper for the other two\ncomponents.\nNone of these components will require special functionality (yet), so they will\nlook similar to our HelloWorld component in that it's just a component with\na single render function.\nLet's build a wrapper component we'll call App that might look similar to this:\n\nclass App extends React.Component {\nrender() {\nreturn (\n<div className=\"notificationsFrame\">\n<div className=\"panel\">{/* content goes here */}</div>\n</div>\n);\n}\n}\n\n23\n\n\fNotice that we use the attribute called className in React\ninstead of the HTML version of class . Remember that we're\nnot writing to the DOM directly and thus not writing HTML,\nbut JSX (which is just JavaScript).\nThe reason we use className is because class is a reserved word in\nJavaScript. If we use class , we'll get an error in our console.","metadata":{"loc":{"lines":{"from":622,"to":648}}}}],["29",{"pageContent":"Child components\nWhen a component is nested inside another component, it's called a child\ncomponent. A component can have multiple children components. The\ncomponent that uses a child component is then called it's parent component.\nWith the wrapper component defined, we can build our title and content\ncomponents by, essentially, grabbing the source from our original design and\nputting the source file into each component.\nFor instance, the header component looks like this, with a container element\n<div className=\"header\"> , the menu icon, a title, and the search bar:\n\n24\n\n\fclass Header extends React.Component {\nrender() {\nreturn (\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">Timeline</span>\n<input type=\"text\" className=\"searchInput\" placeholder=\"Search\n...\" />\n<div className=\"fa fa-search searchIcon\"></div>\n</div>\n);\n}\n}\n\nTimeline\n\n","metadata":{"loc":{"lines":{"from":650,"to":682}}}}],["30",{"pageContent":"Timeline\n\n\n\nAnd finally, we can write the Content component with timeline items. Each\ntimeline item is wrapped in a single component, has an avatar associated\nwith it, a timestamp, and some text.\n\n25\n\n\fclass Content extends React.Component {\nrender() {\nreturn (\n<div className=\"content\">\n<div className=\"line\"></div>\n{/* Timeline item */}\n<div className=\"item\">\n<div className=\"avatar\">\n<img\nalt=\"Doug\"\nsrc=\"http://www.croop.cl/UI/twitter/images/doug.jpg\"\n/>\nDoug\n</div>\n<span className=\"time\">An hour ago</span>\n<p>Ate lunch</p>\n<div className=\"commentCount\">2</div>\n</div>\n{/* ... */}\n</div>\n);\n}\n}\n\n26\n\n\fIn order to write a comment in a React component, we have\nto place it in the brackets as a multi-line comment in\nJavaScript.\nUnlike the HTML comment that looks like this:\n\n<!-- this is a comment in HTML -->\nthe React version of the comment must be in brackets:\n\n{/* This is a comment in React */}","metadata":{"loc":{"lines":{"from":682,"to":726}}}}],["31",{"pageContent":"<!-- this is a comment in HTML -->\nthe React version of the comment must be in brackets:\n\n{/* This is a comment in React */}\n\nPutting it all together\nNow that we have our two children components, we can set the Header and\nthe Content components to be children of the App component. Our App\ncomponent can then use these components as if they are HTML elements\nbuilt-in to the browser. Our new App component, with a header and content\nnow looks like:\n\nclass App extends React.Component {\nrender() {\nreturn (\n<div className=\"notificationsFrame\">\n<div className=\"panel\">\n<Header />\n<Content />\n</div>\n</div>\n);\n}\n}\n\n27\n\n\f\n\nTimeline\n\nDoug\n\nAn hour ago\n\nAte lunch\n\n2\n\n\n\nNote!\nDon't forget to call ReactDOM.render to place your app on the page\n\nvar mountComponent = document.querySelector(\"#app\");\nReactDOM.render(<App />, mountComponent);","metadata":{"loc":{"lines":{"from":726,"to":771}}}}],["32",{"pageContent":"Timeline\n\nDoug\n\nAn hour ago\n\nAte lunch\n\n2\n\n\n\nNote!\nDon't forget to call ReactDOM.render to place your app on the page\n\nvar mountComponent = document.querySelector(\"#app\");\nReactDOM.render(<App />, mountComponent);\n\nWith this knowledge, we now have the ability to write multiple components\nand we can start to build more complex applications.\nHowever, you may notice that this app does not have any user interaction nor\ncustom data. In fact, as it stands right now our React application isn't that\nmuch easier to build than straight, no-frills HTML.\nIn the next section, we'll look how to make our component more dynamic\nand become data-driven with React.\n\n28\n\n\f29\n\n\fData-Driven\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-05/post.md)","metadata":{"loc":{"lines":{"from":771,"to":802}}}}],["33",{"pageContent":"28\n\n\f29\n\n\fData-Driven\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-05/post.md)\n\nHard-coding data in our applications isn't exactly ideal. Today,\nwe'll set up our components to be driven by data to them access\nto external data.\nThrough this point, we've written our first components and set them up in a\nchild/parent relationship. However, we haven't yet tied any data to our React\ncomponents. Although it's a more pleasant experience (in our opinion)\nwriting a website in React, we haven't taken advantage of the power of React\nto display any dynamic data.\nLet's change that today.\n\nGoing data-driven\nRecall, yesterday we built the beginning of our timeline component that\nincludes a header and an activity list:\n\nTimeline\n\n\n\nAn hour ago\n\nAte lunch\n10 am\n30\n\n\fRead Day two article\n10 am\n\nLorem Ipsum is simply dummy text of the printing and\ntypesetting industry.\n2:21 pm","metadata":{"loc":{"lines":{"from":802,"to":838}}}}],["34",{"pageContent":"Timeline\n\n\n\nAn hour ago\n\nAte lunch\n10 am\n30\n\n\fRead Day two article\n10 am\n\nLorem Ipsum is simply dummy text of the printing and\ntypesetting industry.\n2:21 pm\n\nLorem Ipsum has been the industry's standard dummy\ntext ever since the 1500s, when an unknown printer\ntook a galley of type and scrambled it to make a type\nspecimen book.\n\nWe broke down our demo into components and ended up building three\nseparate components with static JSX templates. It's not very convenient to\nhave to update our component's template everytime we have a change in our\nwebsite's data.\nInstead, let's give the components data to use to display. Let's start with the\n<Header /> component. As it stands right now, the <Header /> component\nonly shows the title of the element as Timeline . It's a nice element and it\nwould be nice to be able to reuse it in other parts of our page, but the title of\nTimeline doesn't make sense for every use.\n\nLet's tell React that we want to be able to set the title to something else.","metadata":{"loc":{"lines":{"from":838,"to":870}}}}],["35",{"pageContent":"Let's tell React that we want to be able to set the title to something else.\n\nIntroducing props\nReact allows us to send data to a component in the same syntax as HTML,\nusing attributes or properties on a component. This is akin to passing the src\nattribute to an image tag. We can think about the property of the <img />\ntag as a prop we're setting on a component called img .\n31\n\n\fWe can access these properties inside a component as this.props . Let's see\nprops in action.\nRecall, we defined the <Header /> component as:\n\nclass Header extends React.Component {\nrender() {\nreturn (\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">Timeline</span>\n<input\ntype=\"text\"\nclassName=\"searchInput\"\nplaceholder=\"Search ...\" />\n<div className=\"fa fa-search searchIcon\"></div>\n</div>\n)\n}\n}\n\nWhen we use the <Header /> component, we placed it in our <App />\ncomponent as like so:","metadata":{"loc":{"lines":{"from":870,"to":904}}}}],["36",{"pageContent":"When we use the <Header /> component, we placed it in our <App />\ncomponent as like so:\n\n<Header />\n\n\n\n32\n\n\fWe can pass in our title as a prop as an attribute on the <Header /> by\nupdating the usage of the component setting the attribute called title to\nsome string, like so:\n\n<Header title=\"Timeline\" />\n\nTimeline\n\n\n\nInside of our component, we can access this title prop from the\nthis.props property in the Header class. Instead of setting the title statically\n\nas Timeline in the template, we can replace it with the property passed in.\n\n33\n\n\fclass Header extends React.Component {\nrender() {\nreturn (\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">\n{this.props.title}\n</span>\n<input\ntype=\"text\"\nclassName=\"searchInput\"\nplaceholder=\"Search ...\" />\n<div className=\"fa fa-search searchIcon\"></div>\n</div>\n)\n}\n}","metadata":{"loc":{"lines":{"from":904,"to":950}}}}],["37",{"pageContent":"We've also updated the code slightly to get closer to what our\nfinal <Header /> code will look like, including adding a\nsearchIcon and a few elements to style the menuIcon .\n\nNow our <Header /> component will display the string we pass in as the\ntitle when we call the component. For instance, calling our <Header />\ncomponent four times like so:\n\n34\n\n\f<Header title=\"Timeline\" />\n<Header title=\"Profile\" />\n<Header title=\"Settings\" />\n<Header title=\"Chat\" />\n\nResults in four <Header /> components to mount like so:\n\nTimeline\n\n\n\nProﬁle\n\n\n\nSettings\n\n\n\nChat\n\n","metadata":{"loc":{"lines":{"from":952,"to":983}}}}],["38",{"pageContent":"34\n\n\f<Header title=\"Timeline\" />\n<Header title=\"Profile\" />\n<Header title=\"Settings\" />\n<Header title=\"Chat\" />\n\nResults in four <Header /> components to mount like so:\n\nTimeline\n\n\n\nProﬁle\n\n\n\nSettings\n\n\n\nChat\n\n\n\nPretty nifty, ey? Now we can reuse the <Header /> component with a\ndynamic title property.\nWe can pass in more than just strings in a component. We can pass in\nnumbers, strings, all sorts of objects, and even functions! We'll talk more\nabout how to define these different properties so we can build a component\napi later.\nInstead of statically setting the content and date let's take the Content\ncomponent and set the timeline content by a data variable instead of by text.\nJust like we can do with HTML components, we can pass multiple props into\na component.\nRecall, yesterday we defined our Content container like this:\n35","metadata":{"loc":{"lines":{"from":983,"to":1019}}}}],["39",{"pageContent":"class Content extends React.Component {\nrender() {\nreturn (\n<div className=\"content\">\n<div className=\"line\"></div>\n{/* Timeline item */}\n<div className=\"item\">\n<div className=\"avatar\">\n<img src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\"\n/>\nDoug\n</div>\n<span className=\"time\">\nAn hour ago\n</span>\n<p>Ate lunch</p>\n<div className=\"commentCount\">\n2\n</div>\n</div>\n{/* ... */}\n</div>\n)\n}\n}\n\nAs we did with title , let's look at what props our Content component\nneeds:\nA user's avatar image\nA timestamp of the activity\nText of the activity item\nNumber of comments\n\n36\n\n\fLet's say that we have a JavaScript object that represents an activity item. We\nwill have a few fields, such as a string field (text) and a date object. We might\nhave some nested objects, like a user and comments . For instance:\n\n{\ntimestamp: new Date().getTime(),\ntext: \"Ate lunch\",\nuser: {\nid: 1,\nname: 'Nate',\navatar: \"http://www.croop.cl/UI/twitter/images/doug.jpg\"\n},\ncomments: [\n{ from: 'Ari', text: 'Me too!' }\n]\n}","metadata":{"loc":{"lines":{"from":1021,"to":1071}}}}],["40",{"pageContent":"{\ntimestamp: new Date().getTime(),\ntext: \"Ate lunch\",\nuser: {\nid: 1,\nname: 'Nate',\navatar: \"http://www.croop.cl/UI/twitter/images/doug.jpg\"\n},\ncomments: [\n{ from: 'Ari', text: 'Me too!' }\n]\n}\n\nJust like we passed in a string title to the <Header /> component, we can take\nthis activity object and pass it right into the Content component. Let's\nconvert our component to display the details from this activity inside it's\ntemplate.\nIn order to pass a dynamic variable's value into a template, we have to use the\ntemplate syntax to render it in our template. For instance:\n\n37","metadata":{"loc":{"lines":{"from":1071,"to":1091}}}}],["41",{"pageContent":"37\n\n\fclass Content extends React.Component {\nrender() {\nconst {activity} = this.props; // ES6 destructuring\nreturn (\n<div className=\"content\">\n<div className=\"line\"></div>\n{/* Timeline item */}\n<div className=\"item\">\n<div className=\"avatar\">\n<img\nalt={activity.text}\nsrc={activity.user.avatar} />\n{activity.user.name}\n</div>\n<span className=\"time\">\n{activity.timestamp}\n</span>\n<p>{activity.text}</p>\n<div className=\"commentCount\">\n{activity.comments.length}\n</div>\n</div>\n</div>\n)\n}\n}\n\n38\n\n\fWe've use a little bit of ES6 in our class definition on the first\nline of the render() function called destructuring. The two\nfollowing lines are functionally equivalent:\n// these lines do the same thing\nconst activity = this.props.activity;\nconst {activity} = this.props;\n\nDestructuring allows us to save on typing and define variables in a\nshorter, more compact way.\n\nWe can then use this new content by passing in an object as a prop instead of\na hard-coded string. For instance:\n\n<Content activity={moment1} />","metadata":{"loc":{"lines":{"from":1091,"to":1135}}}}],["42",{"pageContent":"We can then use this new content by passing in an object as a prop instead of\na hard-coded string. For instance:\n\n<Content activity={moment1} />\n\nNate\n\n1582840847478\n\nAte lunch\n\n1\n\n\n\nFantastic, now we have our activity item driven by an object. However, you\nmight have noticed that we would have to implement this multiple times with\ndifferent comments. Instead, we could pass an array of objects into a\ncomponent.\n39\n\n\fLet's say we have an object that contains multiple activity items:\n\nconst activities = [\n{\ntimestamp: new Date().getTime(),\ntext: \"Ate lunch\",\nuser: {\nid: 1, name: 'Nate',\navatar: \"http://www.croop.cl/UI/twitter/images/doug.jpg\"\n},\ncomments: [{ from: 'Ari', text: 'Me too!' }]\n},\n{\ntimestamp: new Date().getTime(),\ntext: \"Woke up early for a beautiful run\",\nuser: {\nid: 2, name: 'Ari',\navatar: \"http://www.croop.cl/UI/twitter/images/doug.jpg\"\n},\ncomments: [{ from: 'Nate', text: 'I am so jealous' }]\n},\n]","metadata":{"loc":{"lines":{"from":1135,"to":1177}}}}],["43",{"pageContent":"We can rearticulate our usage of <Content /> by passing in multiple activities\ninstead of just one:\n\n<Content activities={activities} />\n\nHowever, if we refresh the view nothing will show up! We need to first update\nour Content component to accept multiple activities. As we learned about\npreviously, JSX is really just JavaScript executed by the browser. We can\nexecute JavaScript functions inside the JSX content as it will just get run by\nthe browser like the rest of our JavaScript.\nLet's move our activity item JSX inside of the function of the map function\nthat we'll run over for every item.\n\n40","metadata":{"loc":{"lines":{"from":1179,"to":1192}}}}],["44",{"pageContent":"40\n\n\fclass Content extends React.Component {\nrender() {\nconst {activities} = this.props; // ES6 destructuring\nreturn (\n<div className=\"content\">\n<div className=\"line\"></div>\n{/* Timeline item */}\n{activities.map((activity) => {\nreturn (\n<div className=\"item\">\n<div className=\"avatar\">\n<img\nalt={activity.text}\nsrc={activity.user.avatar} />\n{activity.user.name}\n</div>\n<span className=\"time\">\n{activity.timestamp}\n</span>\n<p>{activity.text}</p>\n<div className=\"commentCount\">\n{activity.comments.length}\n</div>\n</div>\n);\n})}\n</div>\n)\n}\n}\n\nNate 1582840847479\nAte lunch\n\n1582840847479\n\n1\n\n\n\n\n41\n\n\fAri\n\nWoke up early for a beautiful run\n\n1\n\nNow we can pass any number of activities to our array and the Content\ncomponent will handle it, however if we leave the component right now, then\nwe'll have a relatively complex component handling both containing and\ndisplaying a list of activities. Leaving it like this really isn't the React way.","metadata":{"loc":{"lines":{"from":1192,"to":1246}}}}],["45",{"pageContent":"ActivityItem\nHere is where it makes sense to write one more component to contain\ndisplaying a single activity item and then rather than building a complex\nContent component, we can move the responsibility. This will also make it\neasier to test, add functionality, etc.\nLet's update our Content component to display a list of ActivityItem\ncomponents (we'll create this next).\n\n42\n\n\fclass Content extends React.Component {\nrender() {\nconst {activities} = this.props; // ES6 destructuring\nreturn (\n<div className=\"content\">\n<div className=\"line\"></div>\n{/* Timeline item */}\n{activities.map((activity) => (\n<ActivityItem\nactivity={activity} />\n))}\n</div>\n)\n}\n}\n\nNot only is this much simpler and easier to understand, but it makes testing\nboth components easier.\nWith our freshly-minted Content component, let's create the ActivityItem\ncomponent. Since we already have the view created for the ActivityItem , all\nwe need to do is copy it from what was our Content component's template as\nit's own module.\n\n43","metadata":{"loc":{"lines":{"from":1248,"to":1281}}}}],["46",{"pageContent":"43\n\n\fclass ActivityItem extends React.Component {\nrender() {\nconst {activity} = this.props; // ES6 destructuring\nreturn (\n<div className=\"item\">\n<div className=\"avatar\">\n<img\nalt={activity.text}\nsrc={activity.user.avatar} />\n{activity.user.name}\n</div>\n<span className=\"time\">\n{activity.timestamp}\n</span>\n<p>{activity.text}</p>\n<div className=\"commentCount\">\n{activity.comments.length}\n</div>\n</div>\n)\n}\n}\n\nNate 1582840847479\nAte lunch\n\nAri\n\n1582840847479\n\nWoke up early for a beautiful run\n\n1\n\n\n\n1\n\n\n\n44\n\n\fThis week we updated our components to be driven by data by using the\nReact props concept. In the next section, we'll dive into stateful components.\n\n45\n\n\fState\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-06/post.md)","metadata":{"loc":{"lines":{"from":1281,"to":1331}}}}],["47",{"pageContent":"45\n\n\fState\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-06/post.md)\n\nToday we're getting started on how stateful components work in\nReact and look at when and why we'll use state.\nWe've almost made it through the first week of getting up and running on\nReact. We have worked through JSX, building our first components, setting\nup parent-child relationships, and driving our component properties with\nReact. We have one more major idea we have yet to discuss about React, the\nidea of state.","metadata":{"loc":{"lines":{"from":1331,"to":1342}}}}],["48",{"pageContent":"The state of things\nReact does not allow us to modify this.props on our components for good\nreason. Imagine if we passed in the title prop to the Header component\nand the Header component was able to modify it. How do we know what the\ntitle is of the Header component? We set ourselves up for race-conditions,\nconfusing data state, and it would be an all-around bad idea to modify a\nvariable passed to a child component by a parent component.\nHowever, sometimes a component needs to be able to update its own state.\nFor example, setting an active flag or updating a timer on a stopwatch, for\ninstance.\nWhile it's preferable to use props as much as we can, sometimes we need to\nhold on to the state of a component. To handle this, React gives us the ability\nto hold state in our components.\n46\n\n\fstate in a component is intended to be completely internal to the","metadata":{"loc":{"lines":{"from":1344,"to":1359}}}}],["49",{"pageContent":"state in a component is intended to be completely internal to the\n\nComponent and its children (i.e. accessed by the component and any\nchildren it used). Similar to how we access props in a component, the state\ncan be accessed via this.state in a component. Whenever the state changes\n(via the this.setState() function), the component will rerender.\nFor instance, let's say we have a simple clock component that shows the\ncurrent time:","metadata":{"loc":{"lines":{"from":1359,"to":1366}}}}],["50",{"pageContent":"4:00:52 pm\nEven though this is a simple clock component, it does retain state in that it\nneeds to know what the current time is to display. Without using state , we\ncould set a timer and rerender the entire React component, but other\ncomponents on the page may not need rerendering... this would become a\nheadache and slow when we integrate it into a more complex application.\nInstead, we can set a timer to call rerender inside the component and change\njust the internal state of this component.\nLet's take a stab at building this component. First, we'll create the component\nwe'll call Clock .\nBefore we get into the state, let's build the component and create the\nrender() function. We'll need to take into account the number and prepend\n\na zero ( 0 ) to the number if the numbers are smaller than 10 and set the\nam/pm appropriately. The end result of the render() function might look\nsomething like this:\n47","metadata":{"loc":{"lines":{"from":1368,"to":1384}}}}],["51",{"pageContent":"a zero ( 0 ) to the number if the numbers are smaller than 10 and set the\nam/pm appropriately. The end result of the render() function might look\nsomething like this:\n47\n\n\fclass Clock extends React.Component {\nrender() {\nconst currentTime = new Date(),\nhours = currentTime.getHours(),\nminutes = currentTime.getMinutes(),\nseconds = currentTime.getSeconds(),\nampm = hours >= 12 ? 'pm' : 'am';\nreturn (\n<div className=\"clock\">\n{\nhours == 0 ? 12 :\n(hours > 12) ?\nhours - 12 : hours\n}:{\nminutes > 9 ? minutes : `0${minutes}`\n}:{\nseconds > 9 ? seconds : `0${seconds}`\n} {ampm}\n</div>\n)\n}\n}\n\nAlternative padding technique\nAlternatively, we could use the short snippet to handle padding the clock\ntime:\n\n(\"00\" + minutes).slice(-2)\n\nBut we've opted to be more clear with the previous code.","metadata":{"loc":{"lines":{"from":1384,"to":1418}}}}],["52",{"pageContent":"Alternative padding technique\nAlternatively, we could use the short snippet to handle padding the clock\ntime:\n\n(\"00\" + minutes).slice(-2)\n\nBut we've opted to be more clear with the previous code.\n\nIf we render our new Clock component, we will only get a time rendered\neverytime the component itself rerenders. It's not a very useful clock (yet). In\norder to convert our static time display Clock component into a clock that\n48\n\n\fdisplays the time, we'll need to update the time every second.\nIn order to do that, we'll need to track the current time in the state of the\ncomponent. To do this, we'll need to set an initial state value.\nTo do so, we'll first create a getTime() function that returns a javascript\nobject containing hours , minutes , seconds and ampm values. We will call this\nfunction to set our state.","metadata":{"loc":{"lines":{"from":1418,"to":1436}}}}],["53",{"pageContent":"class Clock extends React.Component {\n//...\ngetTime() {\nconst currentTime = new Date();\nreturn {\nhours: currentTime.getHours(),\nminutes: currentTime.getMinutes(),\nseconds: currentTime.getSeconds(),\nampm: currentTime.getHours() >= 12 ? 'pm' : 'am'\n}\n}\n// ...\n}\n\nIn the ES6 class style, we can set the initial state of the component in the\nconstructor() by setting this.state to a value (the return value of our\ngetTime() function).\n\nconstructor(props) {\nsuper(props);\nthis.state = this.getTime();\n}\n\nthis.state will now look like the following object\n\n49\n\n\f{\nhours: 11,\nminutes: 8,\nseconds: 11,\nampm: \"am\"\n}\n\nThe first line of the constructor should always call\nsuper(props) . If you forget this, the component won't like\nyou very much (i.e. there will be errors).\n\nNow that we have a this.state defined in our Clock component, we can\nreference it in the render() function using the this.state . Let's update our\nrender() function to grab the values from this.state :","metadata":{"loc":{"lines":{"from":1438,"to":1478}}}}],["54",{"pageContent":"class Clock extends React.Component {\n// ...\nrender() {\nconst {hours, minutes, seconds, ampm} = this.state;\nreturn (\n<div className=\"clock\">\n{\nhours === 0 ? 12 :\n(hours > 12) ?\nhours - 12 : hours\n}:{\nminutes > 9 ? minutes : `0${minutes}`\n}:{\nseconds > 9 ? seconds : `0${seconds}`\n} {ampm}\n</div>\n)\n}\n}\n\n50\n\n\fInstead of working directly with data values, we can now update the state of\nthe component and separate the render() function from the data\nmanagement.\nIn order to update the state, we'll use a special function called: setState() ,\nwhich will trigger the component to rerender.\n\nWe need to call setState() on the this value of the\ncomponent as it's a part of the React.Component class we are\nsubclassing.\n\nIn our Clock component, let's use the native setTimeout() JavaScript\nfunction to create a timer to update the this.state object in 1000\nmilliseconds. We'll place this functionality in a function as we'll want to call\nthis again.\n\n51","metadata":{"loc":{"lines":{"from":1480,"to":1517}}}}],["55",{"pageContent":"51\n\n\fclass Clock extends React.Component {\n// ...\nconstructor(props) {\nsuper(props);\nthis.state = this.getTime();\n}\n// ...\ncomponentDidMount() {\nthis.setTimer();\n}\n// ...\nsetTimer() {\nclearTimeout(this.timeout);\nthis.timeout = setTimeout(this.updateClock.bind(this), 1000);\n}\n// ...\nupdateClock() {\nthis.setState(this.getTime, this.setTimer);\n}\n// ...\n}\n\nTo start updating the timer immediately after the our\ncomponent has been rendered, we call this.setTimer() in a\nReact component lifecycle method called\ncomponentDidMount .We will get into the lifecycle hooks in the\nnext section.\n\nIn the updateClock() function we'll want to update the state with the new\ntime. We can now update the state in the updateClock() function:\n\n52\n\n\fclass Clock extends React.Component {\n// ...\nupdateClock() {\nthis.setState(this.getTime, this.setTimer);\n}\n// ...\n}","metadata":{"loc":{"lines":{"from":1517,"to":1558}}}}],["56",{"pageContent":"52\n\n\fclass Clock extends React.Component {\n// ...\nupdateClock() {\nthis.setState(this.getTime, this.setTimer);\n}\n// ...\n}\n\nThe component will be mounted on the page and will update the time every\nsecond (approximately every 1000 milliseconds)\nNow the component itself might rerender slower than the timeout function\ngets called again, which would cause a rerendering bottleneck and needlessly\nusing up precious battery on mobile devices. Instead of calling the\nsetTimer() function after we call this.setState() , we can pass a second\n\nargument to the this.setState() function which will be guaranteed to be\ncalled after the state has been updated.\n\nclass Clock extends React.Component {\n// ...\nupdateClock() {\nconst currentTime = new Date();\nthis.setState({\ncurrentTime: currentTime\n}, this.setTimer);\n}\n// ...\n}\n\nHere is our full Clock component code.\n\n53","metadata":{"loc":{"lines":{"from":1558,"to":1591}}}}],["57",{"pageContent":"Here is our full Clock component code.\n\n53\n\n\fclass Clock extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = this.getTime();\n}\ncomponentDidMount() {\nthis.setTimer();\n}\nsetTimer() {\nclearTimeout(this.timeout);\nthis.timeout = setTimeout(this.updateClock.bind(this), 1000);\n}\nupdateClock() {\nthis.setState(this.getTime, this.setTimer);\n}\ngetTime() {\nconst currentTime = new Date();\nreturn {\nhours: currentTime.getHours(),\nminutes: currentTime.getMinutes(),\nseconds: currentTime.getSeconds(),\nampm: currentTime.getHours() >= 12 ? 'pm' : 'am'\n}\n}\nrender() {\nconst {hours, minutes, seconds, ampm} = this.state;\nreturn (\n<div className=\"clock\">\n{hours == 0 ? 12 : hours > 12 ? hours - 12 : hours}:\n{minutes > 9 ? minutes : `0${minutes}`}:\n{seconds > 9 ? seconds : `0${seconds}`} {ampm}\n</div>\n);\n}\n}\n\n54","metadata":{"loc":{"lines":{"from":1591,"to":1631}}}}],["58",{"pageContent":"54\n\n\fStyles\nAs we're not focusing on CSS\n(https://www.w3.org/standards/webdesign/htmlcss) in this course,\nwe're not covering the CSS specific to build the clock as you see it on the\nscreen.\nHowever, we want to make sure the clock you build looks similar to ours.\nIf you include the following CSS as a <link /> tag in your code, your\nclock will look similar and will be using the same styling ours is using:\n\n<link href=\"https://cdn.jsdelivr.net/gh/fullstackreact/30-daysof-react@master/day-06/public/Clock.css\" rel=\"stylesheet\"\ntype=\"text/css\" />\n\n4:00:52 pm\nSome things to keep in mind\nWhen we call this.setState() with an object argument, it will perform\na shallow merge of the data into the object available via this.state and\nthen will rerender the component.\nWe generally only want to keep values in our state that we'll use in the\nrender() function. From the example above with our clock, notice that\nwe stored the hours , minutes , and seconds in our state. It's usually a\n55","metadata":{"loc":{"lines":{"from":1631,"to":1653}}}}],["59",{"pageContent":"bad idea to store objects or calculations in the state that we don't plan\non using in the render function as it can cause unnecessary rendering\nand wasteful CPU cycles.\nAs we noted at the top of this section, it's preferred to use props when\navailable not only for performance reasons, but because stateful components\nare more difficult to test.\nToday, we've updated our components to be stateful and now have a handle\non how to make a component stateful when necessary. Tomorrow we'll dive\ninto the lifecycle of a component and when/how to interact with the page.\n\n56\n\n\fLifecycle Hooks\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-07/post.md)\n\nNOTE: This post is about classic React Lifecycle hooks.\nIf you're looking to learn about the new Hooks API then\nclick here (https://www.fullstackreact.com/articles/anintroduction-to-hooks-in-react/)","metadata":{"loc":{"lines":{"from":1655,"to":1672}}}}],["60",{"pageContent":"Today, we'll look through a few of the most common lifecycle hooks we can\nuse with React components and we'll discuss why they are useful and when\nwe should each one.\nCongrats! We've made it to the end of the first week on React and we've\nalready covered so much ground. We just finished working with stateful\ncomponents to keep track of a component's internal state. Today, we're going\nto pause on implementation and talk a bit about how a component lives in an\napplication. That is, we'll talk about the component's lifecycle.\nAs React mounts our application, it gives us some hooks where we can insert\nour own functionality at different times in the component's lifecycle. In order\nto hook into the lifecycle, we'll need to define functions on our component\nwhich React calls at the appropriate time for each hook. Let's dive into the\nfirst lifecycle hook:\n\ncomponentWillMount() /\ncomponentDidMount()\n57","metadata":{"loc":{"lines":{"from":1674,"to":1690}}}}],["61",{"pageContent":"componentWillMount() /\ncomponentDidMount()\n57\n\n\fWhen a component is defined on a page in our application, we can't depend\nupon it being available in the DOM immediately as we're defining virtual\nnodes. Instead, we have to wait until the component itself has actually\nmounted in the browser. For functionality that we need to run when it has\nbeen mounted, we get two different hooks (or functions) we can define. One\nthat is called just before the component is due to be mounted on the page\nand one that is called just after the component has been mounted.\n\nWhat does mounting mean?\nSince we're defining virtual representations of nodes in our DOM tree\nwith React, we're not actually defining DOM nodes. Instead, we're building\nup an in-memory view that React maintains and manages for us. When we\ntalk about mounting, we're talking about the process of converting the\nvirtual components into actual DOM elements that are placed in the DOM\nby React.","metadata":{"loc":{"lines":{"from":1690,"to":1708}}}}],["62",{"pageContent":"This is useful for things such as fetching data to populate the component. For\ninstance, let's say that we want to use our activity tracker to display github\nevents, for example. We will want to load these events only when the data\nitself is going to be rendered.\nRecall we defined our Content component in our activity list:\n\n58\n\n\fclass Content extends React.Component {\nrender() {\nconst { activities } = this.props; // ES6 destructuring\nreturn (\n<div className=\"content\">\n<div className=\"line\" />\n{/* Timeline item */}\n{activities.map(activity => (\n<ActivityItem activity={activity} />\n))}\n</div>\n);\n}\n}\n\nLet's update the Content component to make a request to the github.com\nevents api (https://developer.github.com/v3/activity/events/) and use the\nresponse to display the activities. As such, we'll need to update the state of\nthe object.\n\nTimeline\n\n\n\nAn hour ago\n\nAte lunch\n10 am\n\nRead Day two article\n10 am\n\nLorem Ipsum is simply dummy text of the printing and\ntypesetting industry.\n2:21 pm","metadata":{"loc":{"lines":{"from":1710,"to":1752}}}}],["63",{"pageContent":"Timeline\n\n\n\nAn hour ago\n\nAte lunch\n10 am\n\nRead Day two article\n10 am\n\nLorem Ipsum is simply dummy text of the printing and\ntypesetting industry.\n2:21 pm\n\nLorem Ipsum has been the industry's standard dummy\ntext ever since the 1500s, when an unknown printer\ntook a galley of type and scrambled it to make a type\nspecimen book.\n59\n\n\fAs we did yesterday, let's update our component to be stateful by setting\nthis.state to an object in the constructor\n\nclass Content extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\nactivities: []\n};\n}\n// ...\n}","metadata":{"loc":{"lines":{"from":1752,"to":1785}}}}],["64",{"pageContent":"class Content extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\nactivities: []\n};\n}\n// ...\n}\n\nNow, we'll want to make an HTTP request when the component itself is\ngetting ready to be mounted (or just after it mounts). By defining the function\ncomponentWillMount() (or componentDidMount() ) in our component, React\nruns the method just before it mounts in the DOM. This is a perfect spot for\nus to add a GET request.\nLet's update the Content component with the request to the github api.\nSince we'll only want to display a small list, let's take the latest four events.\n\n60\n\n\fWe've stored a static JSON file of github data that we'll load\ndirectly from source here (we'll get back to making AJAX\nrequests in a few days) using promises. For now, let's focus on\nhow we'll implement updating our component with new data:\n\nclass Content extends React.Component {\n// ...\ncomponentWillMount() {\nthis.setState({ activities: data });\n}\n// ...\n}","metadata":{"loc":{"lines":{"from":1785,"to":1816}}}}],["65",{"pageContent":"class Content extends React.Component {\n// ...\ncomponentWillMount() {\nthis.setState({ activities: data });\n}\n// ...\n}\n\nLet's also update our ActivityItem component slightly to\nreflect our new activity object structure. We're also using\nMoment.js (https://momentjs.com/) library to format the\ndates into a human friendly string e.g 30 min ago To include\nit in your file, add the following script tag to your document\n<script\nsrc=\"https://unpkg.com/moment@2.24.0/min/moment.min.js\">\n</script>\n\n61\n\n\fclass ActivityItem extends React.Component {\nrender() {\nconst { activity } = this.props;\nreturn (\n<div className='item'>\n<div className={'avatar'}>\n<img\nalt='avatar'\nsrc={activity.actor.avatar_url} />\n</div>\n<span className={'time'}>\n{moment(activity.created_at).fromNow()}\n</span>\n<p>{activity.actor.display_login} {activity.payload.action}\n</p>\n<div className={'right'}>\n{activity.repo.name}\n</div>\n</div>\n)\n}\n}\n\nNotice that we didn't change anything else from our Content component and\nit just works.","metadata":{"loc":{"lines":{"from":1816,"to":1859}}}}],["66",{"pageContent":"Notice that we didn't change anything else from our Content component and\nit just works.\n\n3 years ago\n\nvigosan started\n3 years ago\n\ncaveman started\n3 years ago\n\njamesryancooper started\n3 years ago\n\nelement6 started\n\nfullstackreact/react-yelp-clone\n\nfullstackreact/react-native- restack\n\nfullstackreact/react-native- restack\n\nfullstackreact/react-native-oauth\n62","metadata":{"loc":{"lines":{"from":1859,"to":1882}}}}],["67",{"pageContent":"jamesryancooper started\n3 years ago\n\nelement6 started\n\nfullstackreact/react-yelp-clone\n\nfullstackreact/react-native- restack\n\nfullstackreact/react-native- restack\n\nfullstackreact/react-native-oauth\n62\n\n\fcomponentWillUpdate() /\ncomponentDidUpdate()\nSometimes we'll want to update some data of our component before or after\nwe change the actual rendering. For instance, let's say we want to call a\nfunction to set up the rendering or call a function set when a component's\nprops are changed. The componentWillUpdate() method is a reasonable hook\nto handle preparing our component for a change (as long as we don't call\nthis.setState() to handle it as it will cause an infinite loop).\nSince we won't really need to handle this in-depth, we won't worry about\nsetting up an example here, but it's good to know it exists. A more common\nlifecycle hook we'll use is the componentWillReceiveProps() hook.","metadata":{"loc":{"lines":{"from":1882,"to":1906}}}}],["68",{"pageContent":"componentWillReceiveProps()\nReact will call a method when the component is about to receive new props .\nThis is the first method that will be called when a component is going to\nreceive a new set of props. Defining this method is a good time to look for\nupdates to specific props as it gives us an opportunity to calculate changes\nand update our component's internal state.\nThis is the time when we can update our state based on new props.\n\n63\n\n\fOne thing to keep in mind here is that even though the\ncomponentWillReceiveProps() method gets called, the value of\nthe props may not have changed. It's always a good idea to\ncheck for changes in the prop values.","metadata":{"loc":{"lines":{"from":1908,"to":1921}}}}],["69",{"pageContent":"For instance, let's add a refresh button to our activity list so our users can\nrequest a rerequest of the github events api.\nWe'll use the componentWillReceiveProps() hook to ask the component to\nreload it's data. As our component is stateful, we'll want to refresh this state\nwith new data, so we can't simply update the props in a component. We can\nuse the componentWillReceiveProps() method to tell the component we want\na refresh.\nLet's add a button on our containing element that passes a requestRefresh\nboolean prop to tell the Content component to refresh.\n\n64","metadata":{"loc":{"lines":{"from":1923,"to":1933}}}}],["70",{"pageContent":"64\n\n\fclass Container extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = { refreshing: false };\n}\n// Bound to the refresh button\nrefresh() {\nthis.setState({ refreshing: true });\n}\n// Callback from the `Content` component\nonComponentRefresh() {\nthis.setState({ refreshing: false });\n}\nrender() {\nconst { refreshing } = this.state;\nreturn (\n<div className=\"notificationsFrame\">\n<div className=\"panel\">\n<Header title=\"Github activity\" />\n{/* refreshing is the component's state */}\n<Content\nonComponentRefresh={this.onComponentRefresh.bind(this)}\nrequestRefresh={refreshing}\nfetchData={fetchEvents}\n/>\n{/* A container for styling */}\n<Footer>\n<button onClick={this.refresh.bind(this)}>\n<i className=\"fa fa-refresh\" />\nRefresh\n</button>\n</Footer>\n</div>\n</div>\n);\n}\n}\n65\n\n\f<Footer />\nNotice that we have a new element here that displays the children of the\nelement. This is a pattern which allows us to add a CSS class around some\ncontent.","metadata":{"loc":{"lines":{"from":1933,"to":1977}}}}],["71",{"pageContent":"<Footer />\nNotice that we have a new element here that displays the children of the\nelement. This is a pattern which allows us to add a CSS class around some\ncontent.\n\nclass Footer extends React.Component {\nrender() {\nreturn <div className=\"footer\">{this.props.children}</div>;\n}\n}\n\nUsing this new prop (the requestRefresh prop), we can update the\nactivities from our state object when it changes value.\n\n66\n\n\fclass Content extends React.Component {\nconstructor {\nthis.state = {\nactivities: [],\nloading: false // <~ set loading to false\n};\n}\n// ...\nupdateData() {\nthis.setState(\n{\nloading: false,\nactivities: data.sort(() => 0.5 - Math.random()).slice(0, 4)\n},\nthis.props.onComponentRefresh\n);\n}\ncomponentWillReceiveProps(nextProps) {\n// Check to see if the requestRefresh prop has changed\nif (nextProps.requestRefresh === true) {\nthis.setState({ loading: true }, this.updateData);\n}\n}\n// ...\n}\n\nLet's also update our componentWillMount method to call this.updateData()\ninstead of this.setState","metadata":{"loc":{"lines":{"from":1977,"to":2020}}}}],["72",{"pageContent":"Let's also update our componentWillMount method to call this.updateData()\ninstead of this.setState\n\nclass Content extends React.Component {\n// ...\ncomponentDidMount() {\nthis.updateData();\n}\n// ...\n}\n\n67\n\n\f\n\nTimeline\n\n3 years ago\n\nfullstackreact/react-yelp-clone\n\nvigosan started\n3 years ago\n\njamesryancooper started\n3 years ago\n\nfullstackreact/react-native- restack\n\nfullstackreact/react-native-oauth\n\nelement6 started\n3 years ago\n\nfullstackreact/react-native- restack\n\ncaveman started\n\n Refresh\n\nThis demo is using static data from a JSON file and randomly\npicking four elements when we refresh. This is set up to\nsimulate a refresh.\n\ncomponentWillUnmount()\nBefore the component is unmounted, React will call out to the\ncomponentWillUnmount() callback. This is the time to handle any clean-up\nevents we might need, such as clearing timeouts, clearing data,\n68","metadata":{"loc":{"lines":{"from":2020,"to":2068}}}}],["73",{"pageContent":"disconnecting websockets, etc.\nFor instance, with our clock component we worked on last time, we set a\ntimeout to be called every second. When the component is ready to\nunmount, we want to make sure we clear this timeout so our JavaScript\ndoesn't continue running a timeout for components that don't actually exist.\nRecall that our timer component we built looks like this:\n\nclass Clock extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = this.getTime();\n}\ncomponentDidMount() {\nthis.setTimer();\n}\nsetTimer() {\nthis.timeout = setTimeout(this.updateClock.bind(this), 1000);\n}\nupdateClock() {\nthis.setState(this.getTime, this.setTimer);\n}\ngetTime() {\nconst currentTime = new Date();\nreturn {\nhours: currentTime.getHours(),\nminutes: currentTime.getMinutes(),\nseconds: currentTime.getSeconds(),\nampm: currentTime.getHours() >= 12 ? \"pm\" : \"am\"\n};\n}\n// ...\nrender() {}\n}\n69","metadata":{"loc":{"lines":{"from":2070,"to":2103}}}}],["74",{"pageContent":"When our clock is going to be unmounted, we'll want to clear the timeout we\ncreate in the setTimer() function on the component. Adding the\ncomponentWillUnmount() function takes care of this necessary cleanup.\n\nclass Clock extends React.Component {\n// ...\ncomponentWillUnmount() {\nif (this.timeout) {\nclearTimeout(this.timeout);\n}\n}\n// ...\n}\n\n4:00:55 pm\nThese are a few of the lifecycle hooks we can interact with in the React\nframework. We'll be using these a lot as we build our react apps, so it's a good\nidea to be familiar with them, that they exist, and how to hook into the life of\na component.\nWe did introduce one new concept in this post which we glossed over: we\nadded a callback on a component to be called from the child to it's parent\ncomponent. In the next section, we're going to look at how to define and\ndocument the prop API of a component for usage when sharing a component\nacross teams and an application in general.\n\n70\n\n\f71","metadata":{"loc":{"lines":{"from":2105,"to":2132}}}}],["75",{"pageContent":"70\n\n\f71\n\n\fPackaging and PropTypes\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-08/post.md)\n\nWe're looking at how to make reusable React components today\nso we can share our components across apps and teams.\nPhew! We made it to week two (relatively unscathed)! Through this point,\nwe've talked through most of the basic features of React ( props , state , lifecycle hooks, JSX, etc.).\nIn this section, we're going to look a bit at annotating and packaging our\ncomponents.","metadata":{"loc":{"lines":{"from":2132,"to":2144}}}}],["76",{"pageContent":"PropTypes\nYou may have noticed we use props quite a bit in our components. For the\nmost part, we'll expect these to be a particular type or set of types (aka an\nobject or a string ). React provides a method for defining and validating\nthese types that allow us to easily expose a component API.\nNot only is this a good practice for documentation purposes, it's great for\nbuilding reusable react components (https://reactjs.org/docs/componentsand-props.html).\nThe prop-types object exports a bunch of different types which we can use\nto define what type a component's prop should be. We can define these using\nthe propTypes method in the ES6 class-style React prop:\n\n72\n\n\fclass Clock extends React.Component {\n// ...\n}\nClock.propTypes = {\n// key is the name of the prop and\n// value is the PropType\n}","metadata":{"loc":{"lines":{"from":2146,"to":2165}}}}],["77",{"pageContent":"72\n\n\fclass Clock extends React.Component {\n// ...\n}\nClock.propTypes = {\n// key is the name of the prop and\n// value is the PropType\n}\n\nFrom within this prop , we can define an object which has the key of a prop\nas the name of the prop we are defining and a value defines the type (or\ntypes) it should be defined as.\nFor instance, the Header component we built a few days ago accepts a a prop\ncalled title and we expect it to be a string. We can define it's type to be a\nstring as such:\n\nFirst, we'll need to import the PropTypes object from the\nprop-types package using the import keyword again:\nimport PropTypes from 'prop-types'\n\nYou can also use the PropTypes object directly in your browser by adding\nthe following script tag in your page\n\n<script src=\"https://unpkg.com/prop-types@15.6/proptypes.min.js (https://unpkg.com/prop-types@15.6/proptypes.min.js)\"></script>\n\n73\n\n\fimport PropTypes from 'prop-types'\nclass Header extends React.Component {\n// ...\n}\nHeader.propTypes = {\ntitle: PropTypes.string\n}","metadata":{"loc":{"lines":{"from":2165,"to":2199}}}}],["78",{"pageContent":"73\n\n\fimport PropTypes from 'prop-types'\nclass Header extends React.Component {\n// ...\n}\nHeader.propTypes = {\ntitle: PropTypes.string\n}\n\nReact has a lot of types to choose from, exported on the PropTypes object\nand even allows for us to define a custom object type. Let's look at an overall\nlist of available types:\n\nBasic types\nReact exposes a few basic types we can use out of the box.\ntype\nexample\nString\n'hello'\nNumber\n10, 0.1\nBoolean\ntrue / false\nconst say => (msg) => console.log(\"Hello\nFunction\nworld\")\nSymbol\nSymbol(\"msg\")\nObject\n{name: 'Ari'}\nAnything\n'whatever', 10, {}\n\nclass\nPropTypes.string\nPropTypes.number\nPropTypes.bool\nPropTypes.func\nPropTypes.symbol\nPropTypes.object\n\nIt's possible to tell React we want it to pass through anything that can be\nrendered by using PropTypes.node :\ntype\nexample class\nA rendererable10, 'hello' PropTypes.node\n\n74","metadata":{"loc":{"lines":{"from":2199,"to":2247}}}}],["79",{"pageContent":"It's possible to tell React we want it to pass through anything that can be\nrendered by using PropTypes.node :\ntype\nexample class\nA rendererable10, 'hello' PropTypes.node\n\n74\n\n\fClock.propTypes = {\ntitle: PropTypes.string,\ncount: PropTypes.number,\nisOn: PropTypes.bool,\nonDisplay: PropTypes.func,\nsymbol: PropTypes.symbol,\nuser: PropTypes.object,\nname: PropTypes.node\n}\n\nWe've already looked at how to communicate from a parent component to a\nchild component using props . We can communicate from a child component\nto a parent component using a function. We'll use this pattern quite often\nwhen we want to manipulate a parent component from a child.","metadata":{"loc":{"lines":{"from":2247,"to":2268}}}}],["80",{"pageContent":"Collection types\nWe can pass through iterable collections in our props . We've already seen\nhow we can do this when we passed through an array with our activities. To\ndeclare a component's proptype as an array, we can use the PropTypes.array\nannotation.\nWe can also require that an array holds only objects of a certain type using\nPropTypes.arrayOf([]) .\ntype\nexample\nclass\nArray\n[]\nPropTypes.array\nArray of numbers [1, 2, 3]\nPropTypes.arrayOf([type])\nEnum\n['Red', 'Blue']\nPropTypes.oneOf([arr])\nIt's possible to describe an object that can be one of a few different types as\nwell using PropTypes.oneOfType([types]) .\n\n75\n\n\fClock.propTypes = {\ncounts: PropTypes.array,\nusers: PropTypes.arrayOf(PropTypes.object),\nalarmColor: PropTypes.oneOf(['red', 'blue']),\ndescription: PropTypes.oneOfType([\nPropTypes.string,\nPropTypes.instanceOf(Title)\n]),\n}","metadata":{"loc":{"lines":{"from":2270,"to":2301}}}}],["81",{"pageContent":"Object types\nIt's possible to define types that need to be of a certain shape or instance of a\ncertain class.\ntype\nexample\nclass\n{name: 'Ari'}\nPropTypes.object\nObject\nNumber object {count: 42} PropTypes.objectOf()\nInstance\nnew Message() PropTypes.objectOf()\nObject shape {name: 'Ari'}\nPropTypes.shape()\nClock.propTypes = {\nbasicObject: PropTypes.object,\nnumbers: PropTypes\n.objectOf(PropTypes.numbers),\nmessages: PropTypes\n.instanceOf(Message),\ncontactList: PropTypes.shape({\nname: PropTypes.string,\nphone: PropTypes.string,\n})\n}\n\nReact types\n76\n\n\fWe can also pass through React elements from a parent to a child. This is\nincredibly useful for building templates and providing customization with the\ntemplates.\ntype\nexample class\nElement <Title /> PropTypes.element\nClock.propTypes = {\ndisplayEle: PropTypes.element\n}\n\nWhen we use element, React expects that we'll be able to accept a single child\ncomponent. That is, we won't be able to pass multiple elements.","metadata":{"loc":{"lines":{"from":2303,"to":2343}}}}],["82",{"pageContent":"When we use element, React expects that we'll be able to accept a single child\ncomponent. That is, we won't be able to pass multiple elements.\n\n// Invalid for elements\n<Clock displayElement={\n<div>Name</div>\n<div>Age</div>\n}></Clock>\n// Valid\n<Clock displayElement={\n<div>\n<div>Name</div>\n<div>Age</div>\n</div>\n}></Clock>\n\nRequiring types\nIt's possible to require a prop to be passed to a component by appending any\nof the proptype descriptions with .isRequired :\n\nClock.propTypes = {\ntitle: PropTypes.name.isRequired,\n}\n\n77\n\n\fSetting a prop as required is very useful for times when the component is\ndependent upon a prop to be passed in by it's parent component and won't\nwork without it.\n\nCustom types\nFinally, it's also possible to pass a function to define custom types. We can do\nthis for a single prop or to validate arrays. The one requirement for the\ncustom function is that if the validation does not pass, it expects we'll return\nan Error object:\ntype\n\nexample","metadata":{"loc":{"lines":{"from":2343,"to":2380}}}}],["83",{"pageContent":"example\n\nclass\nfunction(props, propName, componentName)\nCustom\n'something_crazy'\n{}\n['something', PropTypes.arrayOf(function(props, propName,\nCustomArray\ncomponentName) {})\n'crazy']\nUserLink.propTypes = {\nuserWithName: (props, propName, componentName) => {\nif (!props[propName] || !props[propName].name) {\nreturn new Error(\n\"Invalid \" + propName + \": No name property defined for\ncomponent \" + componentName\n)\n}\n}\n}\n\nDefault props\nSometimes we want to be able to set a default value for a prop. For instance,\nour <Header /> component, we built yesterday might not require a title to be\npassed. If it's not, we'll still want a title to be rendered, so we can define a\ncommon title instead by setting it's default prop value.\nTo set a default prop value, we can use the defaultProps object key on the\ncomponent.\n78\n\n\fHeader.defaultProps = {\ntitle: 'Github activity'\n}","metadata":{"loc":{"lines":{"from":2380,"to":2413}}}}],["84",{"pageContent":"Header.defaultProps = {\ntitle: 'Github activity'\n}\n\nPhew, today we went through a lot of documentation. It's always a good idea\nto build our resuable components using the propTypes and defaultProps\nattributes of components. Not only will it make it easier to communicate\nacross developers, it'll be much easier when we return to our components\nafter leaving them for a few days.\nNext, we'll get back to code and start integrating some style into our\ncomponents.\n\n79\n\n\fStyles\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-09/post.md)","metadata":{"loc":{"lines":{"from":2413,"to":2428}}}}],["85",{"pageContent":"79\n\n\fStyles\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-09/post.md)\n\nNo application is complete without style. We'll look at the\ndifferent methods we can use to style our components, from\ntraditional CSS to inline styling.\nThrough this point, we haven't touched the styling of our components\nbeyond attaching Cascading StyleSheet (CSS) class names to components.\nToday, we'll spend time working through a few ways how to style our React\ncomponents to make them look great, yet still keeping our sanity. We'll even\nwork through making working with CSS a bit easier too!\nLet's look at a few of the different ways we can style a component.\n1. Cascasding StyleSheets (CSS)\n2. Inline styles\n3. Styling libraries","metadata":{"loc":{"lines":{"from":2428,"to":2444}}}}],["86",{"pageContent":"CSS\nUsing CSS to style our web applications is a practice we're already familiar\nwith and is nothing new. If you've ever written a web application before, you\nmost likely have used/written CSS. In short, CSS is a way for us to add style\nto a DOM component outside of the actual markup itself.\n\n80\n\n\fUsing CSS alongside React isn't novel. We'll use CSS in React just like we use\nCSS when not using React. We'll assign ids/classes to components and use\nCSS selectors to target those elements on the page and let the browser\nhandle the styling.\nAs an example, let's style our Header component we've been working with a\nbit.\n\nOrange header\n\n\n\nLet's say we wanted to turn the header color orange using CSS. We can easily\nhandle this by adding a stylesheet to our page and targeting the CSS class of\n.header in a CSS class.\nRecall, the render function of our Header component currently looks like\nthis:\n\n81","metadata":{"loc":{"lines":{"from":2446,"to":2471}}}}],["87",{"pageContent":"81\n\n\fclass Header extends React.Component {\nrender() {\nreturn (\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">\n{this.props.title}\n</span>\n<input\ntype=\"text\"\nclassName=\"searchInput\"\nplaceholder=\"Search ...\" />\n<div className=\"fa fa-search searchIcon\"></div>\n</div>\n)\n}\n}\n\nWe can target the header by defining the styles for a .header class in a\nregular css file. As per-usual, we'll need to make sure we use a <link /> tag\nto include the CSS class in our HTML page. Supposing we define our styles in\na file called styles.css in the same directory as the index.html file, this\n<link /> tag will look like the following:\n\n<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n\nLet's fill in the styles for the Header class names:\n\n82","metadata":{"loc":{"lines":{"from":2471,"to":2505}}}}],["88",{"pageContent":"<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\n\nLet's fill in the styles for the Header class names:\n\n82\n\n\f.demo .notificationsFrame .header {\nbackground: rgba(251, 202, 43, 1);\n}\n.demo .notificationsFrame .header .searchIcon,\n.demo .notificationsFrame .header .title {\ncolor: #333333;\n}\n.demo .notificationsFrame .header .menuIcon .dashTop,\n.demo .notificationsFrame .header .menuIcon .dashBottom,\n.demo .notificationsFrame .header .menuIcon .circle {\nbackground-color: #333333;\n}\n\nOrange header\n\n","metadata":{"loc":{"lines":{"from":2505,"to":2526}}}}],["89",{"pageContent":"Orange header\n\n\n\nOne of the most common complaints about CSS in the first place is the\ncascading feature itself. The way CSS works is that it cascades (hence the\nname) parent styles to it's children. This is often a cause for bugs as classes\noften have common names and it's easy to overwrite class styles for nonspecific classes.\nUsing our example, the class name of .header isn't very specific. Not only\ncould the page itself have a header, but content boxes on the page might,\narticles, even ads we place on the page might have a class name of .header .\n\n83\n\n\fOne way we can avoid this problem is to use something like\ncss modules (https://glenmaddern.com/articles/cssmodules) to define custom, very unique CSS class names for\nus. There is nothing magical about CSS modules other than it\nforces our build-tool to define custom CSS class names for us\nso we can work with less unique names. We'll look into using\nCSS modules a bit later in our workflow.","metadata":{"loc":{"lines":{"from":2526,"to":2545}}}}],["90",{"pageContent":"React provides a not-so-new method for avoiding this problem entirely by\nallowing us to define styles inline along with our JSX.\n\nInline styles\nAdding styles to our actual components not only allow us to define the styles\ninside our components, but allow us to dynamically define styles based upon\ndifferent states of the app.\nReact gives us a way to define styles using a JavaScript object rather than a\nseparate CSS file. Let's take our Header component one more time and\ninstead of using css classes to define the style, let's move it to inline styles.\nDefining styles inside a component is easy using the style prop. All DOM\nelements inside React accept a style property, which is expected to be an\nobject with camel-cased keys defining a style name and values which map to\ntheir value.\nFor example, to add a color style to a <div /> element in JSX, this might\nlook like:\n\n<div style={{ color: 'blue' }}>\nThis text will have the color blue\n</div>\n84\n\n\fThis text will have the color blue","metadata":{"loc":{"lines":{"from":2547,"to":2569}}}}],["91",{"pageContent":"<div style={{ color: 'blue' }}>\nThis text will have the color blue\n</div>\n84\n\n\fThis text will have the color blue\n\nNotice that we defined the styles with two braces\nsurrounding it. As we are passing a JavaScript object within a\ntemplate tag, the inner brace is the JS object and the outer is\nthe template tag.\nAnother example to possibly make this clearer would be to pass a\nJavaScript object defined outside of the JSX, i.e.\n\nrender() {\nconst divStyle = { color: 'blue' }\nreturn (<div style={divStyle}>\nThis text will have the color blue\n</div>);\n}\n\nIn any case, as these are JS-defined styles, so we can't use just any ole' css\nstyle name (as background-color would be invalid in JavaScript). Instead,\nReact requires us to camel-case the style name.\n\ncamelCase (https://en.wikipedia.org/wiki/CamelCase) is\nwriting compound words using a capital letter for every word\nwith a capital letter except for the first word, like\nbackgroundColor and linearGradient .\n\n85","metadata":{"loc":{"lines":{"from":2569,"to":2599}}}}],["92",{"pageContent":"85\n\n\fTo update our header component to use these styles instead of depending on\na CSS class definition, we can add the className prop along with a style\nprop:\n\n86\n\n\fclass Header extends React.Component {\nrender() {\nconst wrapperStyle = {\nbackgroundColor: \"rgba(251, 202, 43, 1)\"\n};\nconst titleStyle = {\ncolor: \"#111111\"\n};\nconst menuColor = {\nbackgroundColor: \"#111111\"\n};\nreturn (\n<div style={wrapperStyle} className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\" style={menuColor}></div>\n<div className=\"dashBottom\" style={menuColor}></div>\n<div className=\"circle\" style={menuColor}></div>\n</div>\n<span style={titleStyle} className=\"title\">\n{this.props.title}\n</span>\n<input\ntype=\"text\"\nclassName=\"searchInput\"\nplaceholder=\"Search ...\"\n/>\n<div style={titleStyle} className=\"fa fa-search searchIcon\">\n</div>\n</div>\n);\n}\n}\n\nOur header will be orange again.\n87\n\n\fOrange header\n\n","metadata":{"loc":{"lines":{"from":2599,"to":2645}}}}],["93",{"pageContent":"Our header will be orange again.\n87\n\n\fOrange header\n\n\n\nStyling libraries\nThe React community is a pretty vibrant place (which is one of the reasons it\nis a fantastic library to work with). There are a lot of styling libraries we can\nuse to help us build our styles, such as Radium\n(https://formidable.com/open-source/radium/) by Formidable labs.\nMost of these libraries are based upon workflows defined by React\ndevelopers through working with React.\nRadium allows us to define common styles outside of the React component\nitself, it auto-vendor prefixes, supports media queries (like :hover and\n:active ), simplifies inline styling, and kind of a lot more.","metadata":{"loc":{"lines":{"from":2645,"to":2661}}}}],["94",{"pageContent":"We won't dive into Radium in this post as it's more outside the scope of this\nseries, but knowing other libraries are good to be aware of, especially if\nyou're looking to extend the definitions of your inline styles.\nNow that we know how to style our components, we can make some good\nlooking ones without too much trouble. In the next section, we'll get right\nback to adding user interactivity to our components.\n\n88\n\n\fInteractivity\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-10/post.md)\n\nToday we'll walk through how to add interactivity to our\napplications to make them engaging and dynamic.\nThrough this point, we've built our few handful of components without\nadding much user interaction. Today, we're going to change that.","metadata":{"loc":{"lines":{"from":2663,"to":2678}}}}],["95",{"pageContent":"User interaction\nThe browser is an event-driven application. Everything that a user does in\nthe browser fires an event, from clicking buttons to even just moving the\nmouse. In plain JavaScript, we can listen for these events and attach a\nJavaScript function to interact with them.\nFor instance, we can attach a function to the mousemove browser event with\nthe JS:\n\nconst ele = document.getElementById('mousemove');\nele.innerHTML = 'Move your mouse over this text';\nele.addEventListener('mousemove', function(evt) {\nconst { screenX, screenY } = evt;\nele.innerHTML = '<div>Mouse is at: X: ' +\nscreenX + ', Y: ' + screenY +\n'</div>';\n})\n\n89\n\n\fThis results in the following functionality:\n\nMove your mouse over this text","metadata":{"loc":{"lines":{"from":2680,"to":2701}}}}],["96",{"pageContent":"89\n\n\fThis results in the following functionality:\n\nMove your mouse over this text\n\nIn React, however we don't have to interact with the browser's event loop in\nraw JavaScript as React provides a way for us to handle events using props .\nFor instance, to listen for the mousemove event from the (rather unimpressive)\ndemo above in React, we'll set the prop onMouseMove (notice the camelcasing\nof the event name).\n\n90\n\n\fclass MouseMover extends React.Component {\nstate = {\nx: 0,\ny: 0\n};\nhandleMouseMove = e => {\nthis.setState({\nx: e.clientX,\ny: e.clientY\n});\n};\nrender() {\nreturn (\n<div onMouseMove={this.handleMouseMove}>\n{this.state.x || this.state.y\n? \"The mouse is at x: \" + this.state.x + \", y: \" +\nthis.state.y\n: \"Move the mouse over this box\"}\n</div>\n);\n}\n}","metadata":{"loc":{"lines":{"from":2701,"to":2736}}}}],["97",{"pageContent":"React provides a lot of props we can set to listen for different browser\nevents, such as click, touch, drag, scroll, selection events, and many more\n(see the events (https://facebook.github.io/react/docs/events.html)\ndocumentation for a list of all of them).\n\nThe mouse is at x: unde ned, y: unde ned\n\n91\n\n\fTo see some of these in action, the following is a small demo of some of the\nprops we can pass on our elements. Each text element in the list set the prop\nit lists. Try playing around with the list and seeing how the events are called\nand handled within the element (all events are set on the text, not the list\nitem):\n\n onMouseMove\n\n\n\n onMouseUp\n\n\n\n onMouseDown\n\n\n\n onClick\n\n\n\n onDoubleClick\n\n\n\n onMouseLeave\n\n\n\n onTouchStart\n\n\n\n onTouchEnd\n\n","metadata":{"loc":{"lines":{"from":2738,"to":2783}}}}],["98",{"pageContent":" onMouseMove\n\n\n\n onMouseUp\n\n\n\n onMouseDown\n\n\n\n onClick\n\n\n\n onDoubleClick\n\n\n\n onMouseLeave\n\n\n\n onTouchStart\n\n\n\n onTouchEnd\n\n\n\nWe'll be using the onClick prop quite a bit all throughout our apps quite a\nbit, so it's a good idea to be familiar with it. In our activity list header, we have\na search icon that we haven't hooked up yet to show a search box.\nThe interaction we want is to show a search <input /> when our users click\non the search icon. Recall that our Header component is implemented like\nthis:\n\n92\n\n\fclass Header extends React.Component {\nrender() {\nreturn (\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">\n{this.props.title}\n</span>\n<input\ntype=\"text\"\nclassName=\"searchInput\"\nplaceholder=\"Search ...\" />\n<div className=\"fa fa-search searchIcon\"></div>\n</div>\n)\n}\n}\n\nLet's update it a bit so that we can pass dynamic className prop to the\n<input /> element\n\n93","metadata":{"loc":{"lines":{"from":2783,"to":2849}}}}],["99",{"pageContent":"Let's update it a bit so that we can pass dynamic className prop to the\n<input /> element\n\n93\n\n\fclass Header extends React.Component {\nrender() {\n// Classes to add to the <input /> element\nlet searchInputClasses = [\"searchInput\"];\nreturn (\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">\n{this.props.title}\n</span>\n<input\ntype=\"text\"\nclassName={searchInputClasses.join(' ')}\nplaceholder=\"Search ...\" />\n<div className=\"fa fa-search searchIcon\"></div>\n</div>\n)\n}\n}\n\nWhen the user clicks on the <div className=\"fa fa-search searchIcon\">\n</div> element, we'll want to run a function to update the state of the","metadata":{"loc":{"lines":{"from":2849,"to":2879}}}}],["100",{"pageContent":"When the user clicks on the <div className=\"fa fa-search searchIcon\">\n</div> element, we'll want to run a function to update the state of the\n\ncomponent so the searchInputClasses object gets updated. Using the\nonClick handler, this is pretty simple.\nLet's make this component stateful (it needs to track if the search field\nshould be showing or not). We can convert our component to be stateful\nusing the constructor() function:\n\n94\n\n\fclass Header extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\nsearchVisible: false\n}\n}\n// ...\n}","metadata":{"loc":{"lines":{"from":2879,"to":2898}}}}],["101",{"pageContent":"94\n\n\fclass Header extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\nsearchVisible: false\n}\n}\n// ...\n}\n\nWhat is a constructor function?\nIn JavaScript, the constructor function is a function that runs when an\nobject is created. It returns a reference to the Object function that\ncreated the instance's prototype .\nIn plain English, a constructor function is the function that runs when the\nJavaScript runtime creates a new object. We'll use the constructor method\nto set up instance variables on the object as it runs right when the object\nis created.\nWhen using the ES6 class syntax to create an object, we have to call the\nsuper() method before any other method. Calling the super() function\ncalls the parent class's constructor() function. We'll call it with the same\narguments as the constructor() function of our class is called with.","metadata":{"loc":{"lines":{"from":2898,"to":2921}}}}],["102",{"pageContent":"When the user clicks on the button, we'll want to update the state to say that\nthe searchVisible flag gets updated. Since we'll want the user to be able to\nclose/hide the <input /> field after clicking on the search icon for a second\ntime, we'll toggle the state rather than just set it to true.\nLet's create this method to bind our click event:\n\n95\n\n\fclass Header extends React.Component {\n// ...\nshowSearch() {\nthis.setState({\nsearchVisible: !this.state.searchVisible\n})\n}\n// ...\n}\n\nLet's add an if statement to update searchInputClasses if\nthis.state.searchVisible is true\n\nclass Header extends React.Component {\n// ...\nrender() {\n// ...\n// Update the class array if the state is visible\nif (this.state.searchVisible) {\nsearchInputClasses.push(\"active\");\n}\n// ...\n}\n}\n\nFinally, we can attach a click handler (using the onClick prop) on the icon\nelement to call our new showSearch() method. The entire updated source for\nour Header component looks like this:\n\n96","metadata":{"loc":{"lines":{"from":2923,"to":2960}}}}],["103",{"pageContent":"Finally, we can attach a click handler (using the onClick prop) on the icon\nelement to call our new showSearch() method. The entire updated source for\nour Header component looks like this:\n\n96\n\n\fclass Header extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\nsearchVisible: false\n}\n}\n// toggle visibility when run on the state\nshowSearch() {\nthis.setState({\nsearchVisible: !this.state.searchVisible\n})\n}\nrender() {\n// Classes to add to the <input /> element\nlet searchInputClasses = [\"searchInput\"];\n// Update the class array if the state is visible\nif (this.state.searchVisible) {\nsearchInputClasses.push(\"active\");\n}\nreturn (\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">\n{this.props.title}\n</span>\n<input\ntype=\"text\"\nclassName={searchInputClasses.join(' ')}\nplaceholder=\"Search ...\" />\n97","metadata":{"loc":{"lines":{"from":2960,"to":3000}}}}],["104",{"pageContent":"{/* Adding an onClick handler to call the showSearch button\n*/}\n<div\nonClick={this.showSearch.bind(this)}\nclassName=\"fa fa-search searchIcon\"></div>\n</div>\n)\n}\n}\n\nTry clicking on the search icon and watch the input field appear and\ndisappear (the animation effect is handled by CSS animations).\n\n\n\nInput events\nWhenever we build a form in React, we'll use the input events offered by\nReact. Most notably, we'll use the onSubmit() and onChange() props most\noften.\nLet's update our search box demo to capture the text inside the search field\nwhen it updates. Whenever an <input /> field has the onChange() prop set,\nit will call the function every time the field changes. When we click on it and\nstart typing, the function will be called.\nUsing this prop, we can capture the value of the field in our state.\n\n98","metadata":{"loc":{"lines":{"from":3002,"to":3027}}}}],["105",{"pageContent":"98\n\n\fRather than updating our <Header /> component, let's create a new child\ncomponent to contain a <form /> element. By moving the form-handling\nresponsibilities to it's own form, we can simplify the <Header /> code and we\ncan call up to the parent of the header when our user submits the form (this\nis a usual React pattern).\nLet's create a new component we'll call SearchForm . This new component is a\nstateful component as we'll need to hold on to the value of the search input\n(track it as it changes):\n\nclass SearchForm extends React.Component {\n// ...\nconstructor(props) {\nsuper(props);\nthis.state = {\nsearchText: ''\n}\n}\n// ...\n}\n\nNow, we already have the HTML for the form written in the <Header />\ncomponent, so let's grab that from our Header component and return it from\nour SearchForm.render() function:\n\n99","metadata":{"loc":{"lines":{"from":3027,"to":3053}}}}],["106",{"pageContent":"Now, we already have the HTML for the form written in the <Header />\ncomponent, so let's grab that from our Header component and return it from\nour SearchForm.render() function:\n\n99\n\n\fclass SearchForm extends React.Component {\n// ...\nrender() {\nconst { searchVisible } = this.props;\nlet searchClasses = [\"searchInput\"];\nif (searchVisible) {\nsearchClasses.push(\"active\");\n}\nreturn (\n<form>\n<input\ntype=\"search\"\nclassName={searchClasses.join(\" \")}\nplaceholder=\"Search ...\"\n/>\n</form>\n);\n}\n}\n\nNow that we've moved some code from the Header component to the\nSearchForm , let's update its render method to incorporate the SearchForm\n\n100","metadata":{"loc":{"lines":{"from":3053,"to":3082}}}}],["107",{"pageContent":"Now that we've moved some code from the Header component to the\nSearchForm , let's update its render method to incorporate the SearchForm\n\n100\n\n\fclass Header extends React.Component {\n// ...\nrender() {\nreturn (\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">{this.props.title}</span>\n<SearchForm />\n{/* Adding an onClick handler to call the showSearch button\n*/}\n<div\nonClick={this.showSearch.bind(this)}\nclassName=\"fa fa-search searchIcon\"\n></div>\n</div>\n);\n}\n}","metadata":{"loc":{"lines":{"from":3082,"to":3108}}}}],["108",{"pageContent":"Notice that we lost the styles on our <input /> field. Since we no longer have\nthe searchVisible state in our new component, we can't use it to style the\n<input /> any longer. However, we can pass a prop from our Header\ncomponent that tells the SearchForm to render the input as visible.\nLet's define the searchVisible prop (using PropTypes , of course) and update\nthe render function to use the new prop value to show (or hide) the search\n<input /> . We'll also set a default value for the visibility of the field to be\nfalse (since our Header shows/hides it nicely):\n\n101\n\n\fclass SearchForm extends React.Component {\n// ...\n}\nSearchForm.propTypes = {\nsearchVisible: PropTypes.bool\n}\nSearchForm.defaultProps = {\nsearchVisible: false\n};\n\nIn case you forgot to include PropTypes package in your page\njust add the following script tag in your page\n<script src=\"https://unpkg.com/prop-types@15.6/proptypes.min.js\"></script>","metadata":{"loc":{"lines":{"from":3110,"to":3133}}}}],["109",{"pageContent":"In case you forgot to include PropTypes package in your page\njust add the following script tag in your page\n<script src=\"https://unpkg.com/prop-types@15.6/proptypes.min.js\"></script>\n\nFinally, let's pass the searchVisible state value from Header as a prop to\nSearchForm\n\n102\n\n\fclass Header extends React.Component {\nrender() {\nreturn (\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">{this.props.title}</span>\n<SearchForm searchVisible={this.state.searchVisible} />\n{/* Adding an onClick handler to call the showSearch button\n*/}\n<div\nonClick={this.showSearch.bind(this)}\nclassName=\"fa fa-search searchIcon\"\n></div>\n</div>\n);\n}\n}\n\n","metadata":{"loc":{"lines":{"from":3133,"to":3164}}}}],["110",{"pageContent":"\n\nNow we have our styles back on the <input /> element, let's add the\nfunctionality for when the user types in the search box, we'll want to capture\nthe value of the search field. We can achieve this workflow by attaching the\nonChange prop to the <input /> element and passing it a function to call\nevery time the <input /> element is changed.\n\n103\n\n\fclass SearchForm extends React.Component {\n// ...\nupdateSearchInput(e) {\nconst val = e.target.value;\nthis.setState({\nsearchText: val\n});\n}\n// ...\nrender() {\nconst { searchVisible } = this.state;\nlet searchClasses = ['searchInput']\nif (searchVisible) {\nsearchClasses.push('active')\n}\nreturn (\n<form>\n<input\ntype=\"search\"\nclassName={searchClasses.join(\" \")}\nonChange={this.updateSearchInput.bind(this)}\nplaceholder=\"Search ...\"\n/>\n</form>\n);\n}\n}","metadata":{"loc":{"lines":{"from":3164,"to":3200}}}}],["111",{"pageContent":"When we type in the field, the updateSearchInput() function will be called.\nWe'll keep track of the value of the form by updating the state. In the\nupdateSearchInput() function, we can call directly to this.setState() to\nupdate the state of the component.\n\nThe value is held on the event object's target as\nevent.target.value .\n\n104\n\n\fclass SearchForm extends React.Component {\n// ...\nupdateSearchInput(e) {\nconst val = e.target.value;\nthis.setState({\nsearchText: val\n});\n}\n// ...\n}","metadata":{"loc":{"lines":{"from":3202,"to":3221}}}}],["112",{"pageContent":"104\n\n\fclass SearchForm extends React.Component {\n// ...\nupdateSearchInput(e) {\nconst val = e.target.value;\nthis.setState({\nsearchText: val\n});\n}\n// ...\n}\n\nControlled vs. uncontrolled\nWe're creating what's known as an uncontrolled component as we're not\nsetting the value of the <input /> element. We can't provide any\nvalidation or post-processing on the input text value as it stands right\nnow.\nIf we want to validate the field or manipulate the value of the <input />\ncomponent, we'll have to create what is called a controlled component,\nwhich really just means that we pass it a value using the value prop. A\ncontrolled component version's render() function would look like:\n\nclass SearchForm extends React.Component {\nrender() {\nreturn (\n<input\ntype=\"search\"\nvalue={this.state.searchText}\nclassName={searchInputClasses}\nonChange={this.updateSearchInput.bind(this)}\nplaceholder=\"Search ...\" />\n);\n}\n}\n\n105","metadata":{"loc":{"lines":{"from":3221,"to":3257}}}}],["113",{"pageContent":"105\n\n\fAs of now, we have no way to actually submit the form, so our user's can't\nreally search. Let's change this. We can capture the form submission by using\nthe onSubmit prop on the <form /> element.\nLet's update the render() function to reflect this change.\n\nclass SearchForm extends React.Component {\n// ...\nsubmitForm(event) {\nevent.preventDefault();\n}\n// ...\nrender() {\nconst { searchVisible } = this.props;\nlet searchClasses = ['searchInput']\nif (searchVisible) {\nsearchClasses.push('active')\n}\nreturn (\n<form onSubmit={this.submitForm.bind(this)}>\n<input\ntype=\"search\"\nclassName={searchClasses.join(' ')}\nonChange={this.updateSearchInput.bind(this)}\nplaceholder=\"Search ...\" />\n</form>\n);\n}\n}\n\nWe immediately call event.preventDefault() on the\nsubmitForm() function. This stops the browser from bubbling\nthe event up which would causes the default behavior of the\nentire page to reload (the default function when a browser\nsubmits a form).\n\n106","metadata":{"loc":{"lines":{"from":3257,"to":3294}}}}],["114",{"pageContent":"106\n\n\fNow when we type into the <input /> field and press enter, the\nsubmitForm() function gets called with the event object.\nSo... great, we can submit the form and stuff, but when do we actually do the\nsearching? For demonstration purposes right now, we'll pass the search text\nup the parent-child component chain so the Header can decide what to\nsearch.\n\nThe SearchForm component certainly doesn't know what it's\nsearching, so we'll have to pass the responsibility up the\nchain. We'll use this callback strategy quite a bit.\n\nIn order to pass the search functionality up the chain, our SearchForm will\nneed to accept a prop function to call when the form is submitted. Let's\ndefine a prop we'll call onSubmit that we can pass to our SearchForm\ncomponent. Being good developers, we'll also add a default prop value and a\npropType for this onSubmit function. Since we'll want to make sure the\nonSubmit() is defined, we'll set the onSubmit prop to be a required prop:","metadata":{"loc":{"lines":{"from":3294,"to":3312}}}}],["115",{"pageContent":"class SearchForm extends React.Component {\n// ...\n}\nSearchForm.propTypes = {\nonSubmit: PropTypes.func.isRequired,\nsearchVisible: PropTypes.bool\n}\nSearchForm.defaultProps = {\nonSubmit: () => {},\nsearchVisible: false\n}\n\n107\n\n\fWhen the form is submitted, we can call this function directly from the\nprops . Since we're keeping track of the search text in our state, we can call\nthe function with the searchText value in the state so the onSubmit()\nfunction only gets the value and doesn't need to deal with an event.\n\nclass SearchForm extends React.Component {\n// ...\nsubmitForm(event) {\n// prevent the form from reloading the entire page\nevent.preventDefault();\n// call the callback with the search value\nthis.props.onSubmit(this.state.searchText);\n}\n}\n\nNow, when the user presses enter we can call this onSubmit() function\npassed in the props by our Header component.\nLet's add the onSubmit prop to the SearchForm in the Header component:\n\n108","metadata":{"loc":{"lines":{"from":3314,"to":3347}}}}],["116",{"pageContent":"Now, when the user presses enter we can call this onSubmit() function\npassed in the props by our Header component.\nLet's add the onSubmit prop to the SearchForm in the Header component:\n\n108\n\n\fclass Header extends React.Component {\n// ...\nrender() {\nreturn (\n<div className=\"header\">\n<div className=\"menuIcon\">\n<div className=\"dashTop\"></div>\n<div className=\"dashBottom\"></div>\n<div className=\"circle\"></div>\n</div>\n<span className=\"title\">{this.props.title}</span>\n<SearchForm searchVisible={this.state.searchVisible} onSubmit=\n{this.props.onSearch}/>\n{/* Adding an onClick handler to call the showSearch button\n*/}\n<div\nonClick={this.showSearch.bind(this)}\nclassName=\"fa fa-search searchIcon\"\n></div>\n</div>\n);\n}\n}\n\nNow we have a search form component we can use and reuse across our app.\nOf course, we're not actually searching anything yet. Let's fix that and\nimplement search.","metadata":{"loc":{"lines":{"from":3347,"to":3379}}}}],["117",{"pageContent":"Now we have a search form component we can use and reuse across our app.\nOf course, we're not actually searching anything yet. Let's fix that and\nimplement search.\n\nImplementing search\nTo implement search in our component, we'll want to pass up the search\nresponsibility one more level from our Header component to a container\ncomponent we'll call Panel .\n\n109\n\n\fFirst things first, let's implement the same pattern of passing a callback to a\nparent component from within a child component from the Panel to the\nHeader component.\n\nOn the Header component, let's update the propTypes for a prop we'll define\nas a prop called onSearch :\n\nclass Header extends React.Component {\n// ...\n}\nHeader.propTypes = {\nonSearch: PropTypes.func\n}\n\nHere's our Panel component:\n\n110","metadata":{"loc":{"lines":{"from":3379,"to":3406}}}}],["118",{"pageContent":"class Header extends React.Component {\n// ...\n}\nHeader.propTypes = {\nonSearch: PropTypes.func\n}\n\nHere's our Panel component:\n\n110\n\n\fclass Content extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\nactivities: data,\n};\n}\nrender() {\nconst { activities } = this.state; // ES6 destructuring\nreturn (\n<div>\n<Header\ntitle=\"Github activity\" />\n<div className=\"content\">\n<div className=\"line\" />\n{/* Timeline item */}\n{activities.map(activity => (\n<ActivityItem key={activity.id} activity={activity} />\n))}\n</div>\n</div>\n);\n}\n}\n\n111\n\n\fIn any case, our Panel component is essentially a copy of our\nContent component we previously built on day 7. Make sure\nto include the ActivityItem component in your page. Also\ndon't forget to include Moment.js in your file as it's used by\nActivityItem to format dates. Add the following script tag\nin your page\n<script\nsrc=\"https://unpkg.com/moment@2.24.0/min/moment.min.js\">\n</script>\n\nNotice that our virtual tree looks like this:","metadata":{"loc":{"lines":{"from":3406,"to":3454}}}}],["119",{"pageContent":"Notice that our virtual tree looks like this:\n\n<Panel>\n<Header>\n<SearchForm></SearchForm>\n</Header>\n</Panel>\n\nWhen the <SearchForm /> is updated, it will pass along it's awareness of\nthe search input's change to it's parent, the <Header /> , when it will pass\nalong upwards to the <Panel /> component. This method is very common\nin React apps and provides a good set of functional isolation for our\ncomponents.\n\nBack in our Panel component, we'll pass a function to the Header as the\nonSearch() prop on the Header . What we're saying here is that when the\nsearch form has been submitted, we want the search form to call back to the\nheader component which will then call to the Panel component to handle\nthe search.\n\n112","metadata":{"loc":{"lines":{"from":3454,"to":3474}}}}],["120",{"pageContent":"112\n\n\fSince the Header component doesn't control the content listing, the Panel\ncomponent does, we have to pass the responsibility one more level up, as\nwe're defining here.\nIn order to actually handle the searching, we'll need to pass an onSearch()\nfunction to our Header component. Let's define an onSearch() function in\nour Panel component and pass it off to the Header props in the render()\nfunction:\n\nclass Panel extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\nactivities: data,\n};\n}\nhandleSearch(val) {\n// handle search here\n}\nrender() {\nconst { activities } = this.state; // ES6 destructuring\nreturn (\n<div>\n<Header\ntitle=\"Github activity\"\nonSearch={this.handleSearch.bind(this)}\n/>\n<div className=\"content\">\n<div className=\"line\" />\n{/* Timeline item */}\n{activities.map(activity => (\n<ActivityItem key={activity.id} activity={activity} />\n))}\n</div>\n</div>\n);\n}\n}\n113","metadata":{"loc":{"lines":{"from":3474,"to":3513}}}}],["121",{"pageContent":"All we did here was add a handleSearch() function and pass it to the header.\nNow when the user types in the search box, the handleSearch() function on\nour Panel component will be called.\nLet's update our handleSearch method to actually do the searching:\n\nclass Panel extends React.Component {\n// ...\nhandleSearch(val) {\n// resets the data if the search value is empty\nif (val === \"\") {\nthis.setState({\nactivities: data\n});\n} else {\nconst { activities } = this.state;\nconst filtered = activities.filter(\na => a.actor && a.actor.login.match(val)\n);\nthis.setState({\nactivities: filtered\n});\n}\n}\n// ...\n}","metadata":{"loc":{"lines":{"from":3515,"to":3539}}}}],["122",{"pageContent":"All the activities.filter() function does is run the function passed in for\nevery element and it filters out the values that return falsy values, keeping\nthe ones that return truthy ones. Our search function simply looks for a\nmatch on the Github activity's actor.login (the Github user) to see if it\nregexp-matches the val value.\nWith the handleSearch() function updated, our search is complete.\nTry searching for auser .\n\n114\n\n\fNow we have a 3-layer app component that handles search from a nested\nchild component. We jumped from beginner to intermediate with this post.\nPat yourself on the back. This was some hefty material. Make sure you\nunderstand this because we'll use these concepts we covered today quite\noften.\nIn the next section, we'll jump out and look at building pure components.\n\n115\n\n\fPure Components\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-11/post.md)","metadata":{"loc":{"lines":{"from":3541,"to":3561}}}}],["123",{"pageContent":"React offers several different methods for creating components.\nToday we'll talk about the final method of creating components,\nthe function stateless pure component.\nWe've looked at a few different ways to build react components. One method\nwe left out up through this point is the stateless component/functional\nmethod of building React components.\nAs we've seen up through this point, we've only worked through building\ncomponents using the React.Component and React.createClass() methods.\nFor more performance and simplicity, React also allows us to create pure,\nstateless components using a normal JavaScript function.\nA Pure component can replace a component that only has a render function.\nInstead of making a full-blown component just to render some content to the\nscreen, we can create a pure one instead.\nPure components are the simplest, fastest components we can write. They\nare easy to write, simple to reason about, and the quickest component we","metadata":{"loc":{"lines":{"from":3563,"to":3577}}}}],["124",{"pageContent":"screen, we can create a pure one instead.\nPure components are the simplest, fastest components we can write. They\nare easy to write, simple to reason about, and the quickest component we\ncan write. Before we dive into why these are better, let's write one, or heck a\ncouple!","metadata":{"loc":{"lines":{"from":3577,"to":3581}}}}],["125",{"pageContent":"116\n\n\f// The simplest one\nconst HelloWorld = () => (<div>Hello world</div>);\n// A Notification component\nconst Notification = (props) => {\nconst {level, message} = props;\nconst classNames = ['alert', 'alert-' + level]\nreturn (\n<div className={classNames}>\n{message}\n</div>\n)\n};\n// In ES5\nvar ListItem = function(props) {\nvar handleClick = function(event) {\nprops.onClick(event);\n};\nreturn (\n<div className=\"list\">\n<a\nhref=\"#\"\nonClick={handleClick}>\n{props.children}\n</a>\n</div>\n)\n}","metadata":{"loc":{"lines":{"from":3583,"to":3611}}}}],["126",{"pageContent":"So they are just functions, right? Yep! Since they are just functions, it's really\neasy to test using pure JavaScript. The idea is that if React knows the props\nthat are sent into a component, it can be deterministic in knowing if it has to\nrerender or not. The same props in equal the same output virtual DOM.\nIn React, functional components are called with an argument of props\n(similar to the React.Component constructor class), which are the props it's\ncalled with as well as with the current context of the component tree.\n\n117\n\n\fFor instance, let's say we want to rewrite our original Timer component\nusing functional components as we want to give our users a dynamic way to\nset their own clock styles (24 hour clock vs. 12, different separators, maybe\nthey don't want to display the seconds, etc).\nWe can break up our clock into multiple components where we can use each\nblock of time as an individual component. We might break them up like so:","metadata":{"loc":{"lines":{"from":3613,"to":3628}}}}],["127",{"pageContent":"const Hour\n= (props) => {\nlet {hours} = props;\nif (hours === 0) { hours = 12; }\nif (props.twelveHours) { hours -= 12; }\nreturn (<span>{hours}</span>)\n}\nconst Minute = ({minutes}) => (<span>{minutes<10 && '0'}{minutes}\n</span>)\nconst Second = ({seconds}) => (<span>{seconds<10 && '0'}{seconds}\n</span>)\nconst Separator = ({separator}) => (<span>{separator || ':'}</span>)\nconst Ampm = ({hours}) => (<span>{hours >= 12 ? 'pm' : 'am'}</span>)\n\nWith these, we can place individual components as through they are fullblown React components (they are):\n\n<div>Minute: <Minute minutes={12} /></div>\n<div>Second: <Second seconds={51} /></div>\n\nMinute: 12\nSecond: 51\n118\n\n\fWe can refactor our clock component to accept a format string and break up\nthis string selecting only the components our user is interested in showing.\nThere are multiple ways we can handle this, like forcing the logic into the\nClock component or we can create another stateless component that","metadata":{"loc":{"lines":{"from":3630,"to":3656}}}}],["128",{"pageContent":"accepts a format string. Let's do that (easier to test):\n\nconst Formatter = (props) => {\nlet children = props.format.split('').map((e, idx) => {\nif (e === 'h') {\nreturn <Hour key={idx} {...props} />\n} else if (e === 'm') {\nreturn <Minute key={idx} {...props} />\n} else if (e === 's') {\nreturn <Second key={idx} {...props} />\n} else if (e === 'p') {\nreturn <Ampm key={idx} {...props} />\n} else if (e === ' ') {\nreturn <span key={idx}> </span>;\n} else {\nreturn <Separator key={idx} {...props} />\n}\n});\nreturn <span>{children}</span>;\n}\n\nThis is a little ugly with the key and {...props} thingie in there. React gives\nus some helpers for mapping over children and taking care of handling the\nunique key for each child through the React.Children object.\nThe render() function of our Clock component can be greatly simplified\nthanks to the Formatter component into this:\n\n119","metadata":{"loc":{"lines":{"from":3658,"to":3685}}}}],["129",{"pageContent":"119\n\n\fclass Clock extends React.Component {\nstate = { currentTime: new Date() }\ncomponentDidMount() {\nthis.setState({\ncurrentTime: new Date()\n}, this.updateTime);\n}\ncomponentWillUnmount() {\nif (this.timerId) {\nclearTimeout(this.timerId)\n}\n}\nupdateTime = e => {\nthis.timerId = setTimeout(() => {\nthis.setState({\ncurrentTime: new Date()\n}, this.updateTime);\n})\n}\nrender() {\nconst { currentTime } = this.state\nconst hour = currentTime.getHours();\nconst minute = currentTime.getMinutes();\nconst second = currentTime.getSeconds();\nreturn (\n<div className='clock'>\n<Formatter\n{...this.props}\nstate={this.state}\nhours={hour}\nminutes={minute}\nseconds={second}\n/>\n</div>\n)\n}\n}\n\nWe can now render the clock in a custom format:\n\n120\n\n\fReactDOM.render(<Clock format=\"h:m:s p\" />,\ndocument.querySelector(\"#app\"));\n\nNot only is our Clock component much simpler, but it's so much easier to\ntest. It also will help us transition to using a data state tree, like Flux/Redux\nframeworks, but more on those later.\n\n16:01:11 pm","metadata":{"loc":{"lines":{"from":3685,"to":3736}}}}],["130",{"pageContent":"16:01:11 pm\n\nUhh... so why care?\nAdvantages to using functional components in React are:\nWe can do away with the heavy lifting of components, no constructor,\nstate, life-cycle madness, etc.\nThere is no this keyword (i.e. no need to bind)\nPresentational components (also called dumb components) emphasize\nUI over business logic (i.e. no state manipulation in the component)\nEncourages building smaller, self-contained components\nHighlights badly written code (for better refactoring)\nFAST FAST FAST FAST FAST\nThey are easy to reuse\nYou might say why not use a functional component? Well, some of the\ndisadvantage of using a functional component are some of the advantages:\nNo life-cycle callback hooks\nLimited functionality\nThere is no this keyword\n121","metadata":{"loc":{"lines":{"from":3736,"to":3754}}}}],["131",{"pageContent":"Overall, it's a really good idea to try to prefer using functional components\nover their heavier React.Component cousins. When we get to talking about\ndata management in React, we'll see how we can use these presentational\ncomponents with data as pure props .\nNice work today. We've successfully achieved React rank after today. We now\nknow the three ways to make a React Component.\nTomorrow, we'll get set up using/building React apps with the package\nmanagement tool shipped by the React team: create-react-app .\n\n122\n\n\fcreate-react-app\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-12/post.md)","metadata":{"loc":{"lines":{"from":3756,"to":3768}}}}],["132",{"pageContent":"122\n\n\fcreate-react-app\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-12/post.md)\n\nToday, we're going to add a build process to store common build\nactions so we can easily develop and deploy our applications.\nThe React team noticed that there is a lot of configuration required (and the\ncommunity helped bloat -- us included) to run a React app. Luckily, some\nsmart folks in the React team/community got together and built/released an\nofficial generator app that makes it much easier to get up and running\nquickly.","metadata":{"loc":{"lines":{"from":3768,"to":3779}}}}],["133",{"pageContent":"Packaging\nSo far in this course, we've only been working with writing our components\nin a single script. Although it's great for simplicity, it can be difficult to share\ncomponents amongst multiple developers. A single file is also pretty difficult\nto write complex applications.\nInstead, we'll set up a build tool for our applications using a very popular\npackaging tool called create-react-app\n(https://github.com/facebookincubator/create-react-app). The tool\nprovides a great place to start out developing our applications without\nneeding to spend too much time working on setting up our build tooling.\nIn order to use it, we'll need to start out by installing it. We can use npm or\nyarn to install create-react-app :\n\n123","metadata":{"loc":{"lines":{"from":3781,"to":3794}}}}],["134",{"pageContent":"123\n\n\fcreate-react-app\nThe create-react-app (https://github.com/facebookincubator/create-reactapp) project is released through Facebook helps us get up and running\nquickly with a React app on our system with no custom configuring required\non our part.\nThe package is released as a Node (https://nodejs.org/) Package\n(https://www.npmjs.com/package/create-react-app) and can be installed\nusing npm .\n\nA plug for nvm and n\nThe Node (https://nodejs.org) homepage has simple documentation on\nhow to install node, if you don't already have it installed on your system.\nWe recommend using the nvm (https://github.com/creationix/nvm) or\nthe n (https://github.com/tj/n) version management tools. These tools\nmake it incredibly easy to install/use multiple versions of node on your\nsystem at any point.\n\nWith node installed on our system, we can install the create-react-app\npackage:\n\nnpm install --global create-react-app\n\n124","metadata":{"loc":{"lines":{"from":3794,"to":3817}}}}],["135",{"pageContent":"With node installed on our system, we can install the create-react-app\npackage:\n\nnpm install --global create-react-app\n\n124\n\n\fWith create-react-app installed globally, we'll be able to use the createreact-app command anywhere in our terminal.\nLet's create a new app we'll call 30days using the create-react-app\ncommand we just installed. Open a Terminal window in a directory where\nyou want to create your app.\nIn terminal, we can create a new React application using the command and\nadding a name to the app we want to create.\n\ncreate-react-app 30days && cd 30days\n\n125\n\n\fLet's start our app in the browser. The create-react-app package comes with\na few built-in scripts it created for us (in the package.json file). We can start\nediting our app using the built-in webserver using the npm start command:\n\nnpm start\n\n126\n\n\fThis command will open a window in Chrome to the default app it created for\nus running at the url: http://localhost:3000/ (http://localhost:3000/).","metadata":{"loc":{"lines":{"from":3817,"to":3844}}}}],["136",{"pageContent":"npm start\n\n126\n\n\fThis command will open a window in Chrome to the default app it created for\nus running at the url: http://localhost:3000/ (http://localhost:3000/).\n\nLet's edit the newly created app. Looking at the directory structure it\ncreated, we'll see we have a basic node app running with a\npublic/index.html and a few files in the src/ directory that comprise our\nrunning app.\n\n127\n\n\fLet's open up the src/App.js file and we'll see we have a very basic\ncomponent that should all look familiar. It has a simple render function which\nreturns the result we see in the Chrome window.\n\nThe index.html file has a single <div /> node with the id of #root , where\nthe app itself will be mounted for us automatically (this is handled in the\nsrc/index.js file). Anytime we want to add webfonts, style tags, etc. we can\nload them in the index.html file.\n\n128","metadata":{"loc":{"lines":{"from":3844,"to":3867}}}}],["137",{"pageContent":"128\n\n\fLet's look at a few of the features create-react-app enables for us.\nWe've used multiple components in the past. Let's pull in the example we\nwalked through on day-4 with a header and content (slightly simplified -changing the className from notificationsFrame to App and removing the\ninner component):\n\nimport React from \"react\";\nclass App extends React.Component {\nrender() {\nreturn (\n<div className=\"App\">\n<Header />\n<Content />\n</div>\n);\n}\n}\n\nWe could define the Header and the Content component in the same file, but\nas we discussed, that becomes pretty cumbersome. Instead, let's create a\ndirectory called components/ in the src/ directory ( src/components/ ) and\ncreate two files called Header.js and Content.js in there:\n\n# in my-app/\nmkdir src/components\ntouch src/components/{Header,Content}.js\n\nNow, let's write the two components in their respective file. First, the Header\ncomponents in src/components/Header.js :\n\n129","metadata":{"loc":{"lines":{"from":3867,"to":3898}}}}],["138",{"pageContent":"# in my-app/\nmkdir src/components\ntouch src/components/{Header,Content}.js\n\nNow, let's write the two components in their respective file. First, the Header\ncomponents in src/components/Header.js :\n\n129\n\n\fimport React from \"react\";\nclass Header extends React.Component {\nrender() {\nreturn (\n<div id=\"header\">\n<h1>Header</h1>\n</div>\n);\n}\n}\n\nAnd now let's write the Content component in the\nsrc/components/Content.js file:\n\nimport React from \"react\";\nclass Content extends React.Component {\nrender() {\nreturn <p className=\"App-intro\">Content goes here</p>;\n}\n}\n\nBy making a small update to these two component definitions, we can then\nimport them into our App component (in src/App.js ).\n\nWe'll use the export keyword before the class definition:\nLet's update the Header component slightly:\n\nexport class Header extends React.Component {\n// ...\n}\n\nand the Content component:\n\n130\n\n\fexport class Content extends React.Component {\n// ...\n}","metadata":{"loc":{"lines":{"from":3898,"to":3944}}}}],["139",{"pageContent":"export class Header extends React.Component {\n// ...\n}\n\nand the Content component:\n\n130\n\n\fexport class Content extends React.Component {\n// ...\n}\n\nNow we can import these two component from our src/App.js file. Let's\nupdate our App.js by adding these two import statements:\n\nimport React from \"react\";\nimport { Header } from \"./components/Header\";\nimport { Content } from \"./components/Content\";\nclass App extends React.Component {\nrender() {\nreturn (\n<div className=\"App\">\n<Header />\n<Content />\n</div>\n);\n}\n}\n\nHere, we're using named exports to pull in the two components from their\nrespective files in src/components/ .\nBy convention, if we only have a single export from these files, we can use the\nexport default syntax so we can remove the {} surrounding the named\n\nexport. Let's update each of these respective files to include an extra line at\nthe end to enable the default import:\n\nexport class Header extends React.Component {\n// ...\n}\nexport default Header;\n\n131\n\n\fand the Content component:","metadata":{"loc":{"lines":{"from":3944,"to":3988}}}}],["140",{"pageContent":"export class Header extends React.Component {\n// ...\n}\nexport default Header;\n\n131\n\n\fand the Content component:\n\nexport class Content extends React.Component {\n// ...\n}\nexport default Content;\n\nNow we can update our import of the two components like so:\n\nimport React from \"react\";\nimport Header from \"./components/Header\";\nimport Content from \"./components/Content\";\nclass App extends React.Component {\nrender() {\nreturn (\n<div className=\"App\">\n<Header />\n<Content />\n</div>\n);\n}\n}\n\nUsing this knowledge, we can now also update our components by importing\nthe named Component class and simplify our definition of the class file again.\nLet's take the Content component in src/components/Content.js :\n\n132\n\n\fimport React, {Component} from 'react'; // This is the change\nexport class Content extends Component { // and this allows us\n// to not call\nReact.Component\n// but instead use just\n// the Component class\nrender() {\nreturn <p className=\"App-intro\">Content goes here</p>;\n}\n}\nexport default Content;","metadata":{"loc":{"lines":{"from":3988,"to":4034}}}}],["141",{"pageContent":"Shipping\nWe'll get to deployment in a few weeks, but for the time being know that the\ngenerator created a build command so we can create minified, optimize\nversions of our app that we can upload to a server.\nWe can build our app using the npm run build command in the root of our\nproject:\n\nnpm run build\n\n133\n\n\fWith that, we now have a live-reloading single-page app (SPA) ready for\ndevelopment. Tomorrow, we'll use this new app we built diving into\nrendering multiple components at run-time.\n\n134\n\n\fRepeating Elements\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-13/post.md)\n\nToday we're going to work through how to display multiple\ncomponents in preparation for pulling in external data into our\napp.\nUp through this point, we've been building a basic application without any\nexternal data. Before we get there (we'll start on this functionality tomorrow),\nlet's look over something we glossed over in the previous two weeks:","metadata":{"loc":{"lines":{"from":4036,"to":4061}}}}],["142",{"pageContent":"Repeating elements\nWe've already seen this before where we've iterated over a list of objects and\nrender multiple components on screen. Before we add too much complexity\nin our app with loading external data, today we'll take a quick peek at how to\nrepeat components/elements in our app.\nSince JSX is seen as plain JavaScript by the browser, we can use any ole'\nJavaScript inside the template tags in JSX. We've already seen this in action.\nAs a quick demo:\n\n135\n\n\fconst a = 10;\nconst ShowA = () => <div>{a}</div>;\nconst MultipleA = () => <div>{a * a}</div>;\nconst App = props => {\nreturn (\n<div className=\"app\">\n<ShowA />\n<MultipleA />\n</div>\n);\n};\n\n10\n100","metadata":{"loc":{"lines":{"from":4063,"to":4087}}}}],["143",{"pageContent":"135\n\n\fconst a = 10;\nconst ShowA = () => <div>{a}</div>;\nconst MultipleA = () => <div>{a * a}</div>;\nconst App = props => {\nreturn (\n<div className=\"app\">\n<ShowA />\n<MultipleA />\n</div>\n);\n};\n\n10\n100\n\nNotice the things inside of the template tags {} look like simple JavaScript.\nThat's because it is just JavaScript. This feature allows us to use (most) native\nfeatures of JavaScript inside our template tags including native iterators,\nsuch as map and forEach .\nLet's see what we mean here. Let's convert the previous example's a value\nfrom a single integer to a list of integers:\n\nconst a = [1, 10, 100, 1000, 10000];\n\nWe can map over the a variable here inside our components and return a list\nof React components that will build the virtual DOM for us.\n\n136\n\n\fconst a = [1, 10, 100, 1000, 10000];\nconst Repeater = () => {\nreturn (\n<ul>\n{a.map(i => {\nreturn <li>{i}</li>;\n})}\n</ul>\n);\n};","metadata":{"loc":{"lines":{"from":4087,"to":4127}}}}],["144",{"pageContent":"136\n\n\fconst a = [1, 10, 100, 1000, 10000];\nconst Repeater = () => {\nreturn (\n<ul>\n{a.map(i => {\nreturn <li>{i}</li>;\n})}\n</ul>\n);\n};\n\nWhat is the map() function?\nThe map function is a native JavaScript built-in function on the array. It\naccepts a function to be run on each element of the array, so the function\nabove will be run four times with the value of i starting as 1 and then it\nwill run it again for the second value where i will be set as 10 and so on\nand so forth.\n\n1\n10\n100\n1000\n\nLet's update the app we created on day 12 with our App component here.\nLet's open up our src/App.js file and replace the content of the App\ncomponent with this source. Cleaning up a few unused variables and your\nsrc/App.js should look similar to this:\n\n137\n\n\fimport React from \"react\";\nconst a = [1, 10, 100, 1000, 10000];\nconst App = props => {\nreturn (\n<ul>\n{a.map(i => {\nreturn <li>{i}</li>;\n})}\n</ul>\n);\n};\nexport default App;","metadata":{"loc":{"lines":{"from":4127,"to":4170}}}}],["145",{"pageContent":"137\n\n\fimport React from \"react\";\nconst a = [1, 10, 100, 1000, 10000];\nconst App = props => {\nreturn (\n<ul>\n{a.map(i => {\nreturn <li>{i}</li>;\n})}\n</ul>\n);\n};\nexport default App;\n\nStarting the app again with the command generated by the create-react-app\ncommand: npm start , we can see the app is working in the browser!\n\nHowever, if we open the developer console, we'll see we have an error\nprinted out. This error is caused by the fact that React doesn't know how to\nkeep track of the individual components in our list as each one just looks like\na <li /> component.\n138","metadata":{"loc":{"lines":{"from":4170,"to":4192}}}}],["146",{"pageContent":"For performance reasons, React uses the virtual DOM to attempt to limit the\nnumber of DOM elements that need to be updated when it rerenders the\nview. That is if nothing has changed, React won't make the browser update\nanything to save on work.\nThis feature is really fantastic for building web applications, but sometimes\nwe have to help React out by providing unique identifiers for nodes. Mapping\nover a list and rendering components in the map is one of those times.\nReact expects us to uniquely identify components by using a special prop:\nthe key prop for each element of the list. The key prop can be anything we\nwant, but it must be unique for that element. In our example, we can use the\ni variable in the map as no other element in the array has the same value.\n\nLet's update our mapping to set the key:\n\nconst App = props => {\nreturn (\n<ul>\n{a.map(i => {\nreturn <li key={i}>{i}</li>;\n})}\n</ul>\n);\n};","metadata":{"loc":{"lines":{"from":4194,"to":4216}}}}],["147",{"pageContent":"Let's update our mapping to set the key:\n\nconst App = props => {\nreturn (\n<ul>\n{a.map(i => {\nreturn <li key={i}>{i}</li>;\n})}\n</ul>\n);\n};\n\nChildren\nWe talked about building a parent-child relationship a bit earlier this week,\nbut let's dive a bit more into detail about how we get access to the children\ninside a parent component and how we can render them.\nOn day 11, we built a <Formatter /> component to handle date formatting\nwithin the Clock component to give our users flexibility with their own\ncustom clock rendering. Recall that the implementation we created is\nactually pretty ugly and relatively complex.\n139","metadata":{"loc":{"lines":{"from":4216,"to":4236}}}}],["148",{"pageContent":"const Formatter = props => {\nlet children = props.format.split(\"\").map((e, idx) => {\nif (e === \"h\") {\nreturn <Hour key={idx} {...props} />;\n} else if (e === \"m\") {\nreturn <Minute key={idx} {...props} />;\n} else if (e === \"s\") {\nreturn <Second key={idx} {...props} />;\n} else if (e === \"p\") {\nreturn <Ampm key={idx} {...props} />;\n} else if (e === \" \") {\nreturn <span key={idx}> </span>;\n} else {\nreturn <Separator key={idx} {...props} />;\n}\n});\nreturn <span>{children}</span>;\n};\n\nWe can use the React.Children object to map over a list of React objects and\nlet React do this heavy-lifting. The result of this is a much cleaner Formatter\ncomponent (not perfect, but functional):\n\n140","metadata":{"loc":{"lines":{"from":4238,"to":4261}}}}],["149",{"pageContent":"We can use the React.Children object to map over a list of React objects and\nlet React do this heavy-lifting. The result of this is a much cleaner Formatter\ncomponent (not perfect, but functional):\n\n140\n\n\fconst Formatter = props => {\nlet children = props.format.split(\"\").map(e => {\nif (e == \"h\") {\nreturn <Hour />;\n} else if (e == \"m\") {\nreturn <Minute />;\n} else if (e == \"s\") {\nreturn <Second />;\n} else if (e == \"p\") {\nreturn <Ampm />;\n} else if (e == \" \") {\nreturn <span> </span>;\n} else {\nreturn <Separator />;\n}\n});\nreturn (\n<span>\n{React.Children.map(children, c => React.cloneElement(c,\nprops))}\n</span>\n);\n};\n\n141\n\n\fReact.cloneElement\nWe have yet to talk about the React.cloneElement() function, so let's look\nat it briefly here. Remember WWWWWAAAAAYYYYY back on day 2 we\nlooked at how the browser sees JSX? It turns it into JavaScript that looks\nsimilar to:","metadata":{"loc":{"lines":{"from":4261,"to":4297}}}}],["150",{"pageContent":"React.createElement(\"div\", null,\nReact.createElement(\"img\", {src: \"profile.jpg\", alt: \"Profile\nphoto\"}),\nReact.createElement(\"h1\", null, \"Welcome back Ari\")\n);\n\nRather than creating a new component instance (if we already have one),\nsometimes we'll want to copy it or add custom props/children to the\ncomponent so we can retain the same props it was created with. We can\nuse React.cloneElement() to handle this for us.\nThe React.cloneElement() has the same API as the\nReact.createElement() function where the arguments are:\n1. The ReactElement we want to clone\n2. Any props we want to add to the instance\n3. Any children we want it to have.\nIn our Formatter example, we're creating a copy of all the children in the\nlist (the <Hour /> , <Minute /> , etc. components) and passing them the\nprops object as their props.","metadata":{"loc":{"lines":{"from":4299,"to":4316}}}}],["151",{"pageContent":"The React.Children object provides some nice utility functions for dealing\nwith children. Our Formatter example above uses the map function to iterate\nthrough the children and clone each one in the list. It creates a key (if\nnecessary) for each one, freeing us from having to manage the uniqueness\nourselves.\nLet's use the React.Children.map() function to update our App component:\n\n142\n\n\fconst App = props => {\nreturn (\n<ul>\n{React.Children.map(a, i => (\n<li>{i}</li>\n))}\n</ul>\n);\n};\n\nBack in the browser, everything still works.","metadata":{"loc":{"lines":{"from":4318,"to":4337}}}}],["152",{"pageContent":"142\n\n\fconst App = props => {\nreturn (\n<ul>\n{React.Children.map(a, i => (\n<li>{i}</li>\n))}\n</ul>\n);\n};\n\nBack in the browser, everything still works.\n\nThere are several other really useful methods in the React.Children object\navailable to us. We'll mostly use the React.Children.map() function, but it's\ngood to know about the other ones available\n(https://facebook.github.io/react/docs/top-level-api.html#react.children)\nto us. Check out the documentation\n(https://facebook.github.io/react/docs/top-level-api.html#react.children)\nfor a longer list.\nUp through this point, we've only dealt with local data, not really focusing on\nremote data (although we did briefly mention it when building our activity\nfeed component). Tomorrow we're going to get into interacting with a server\n143\n\n\fso we can use it in our React apps.\nGreat work today!\n\n144\n\n\fFetching Remote Data\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-14/post.md)","metadata":{"loc":{"lines":{"from":4337,"to":4369}}}}],["153",{"pageContent":"so we can use it in our React apps.\nGreat work today!\n\n144\n\n\fFetching Remote Data\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-14/post.md)\n\nWe're ready to make an external request to fetch data! Today\nwe're looking at the first step of making a call to an external API.\nOur apps, until this point have largely been static. Even the data we displayed\nfrom Github was static data included in our project. Our apps are really only\nas interesting as the data we use, so let's make our apps more interesting.","metadata":{"loc":{"lines":{"from":4369,"to":4381}}}}],["154",{"pageContent":"Querying for remote data\nThe normal browser workflow is actually a synchronous one. When the\nbrowser receives html, it parses the string of html content and converts it\ninto a tree object (this is what we often refer to as the DOM object/DOM\ntree).\nWhen the browser parses the DOM tree, as it encounters remote files (such\nas <link /> and <script /> tags), the browser will request these files (in\nparallel), but will execute them synchronously (so as to maintain their order\nthey are listed in the source).\nWhat if we want to get some data from off-site? We'll make requests for data\nthat's not available at launch time to populate data in our app. However, it's\nnot necessarily that easy to do because of the asynchronous nature of\nexternal API requests.\n\n145","metadata":{"loc":{"lines":{"from":4383,"to":4397}}}}],["155",{"pageContent":"145\n\n\fEssentially, what this means is that we'll have to handle with JavaScript code\nafter an unknown period of time as well actually make an HTTP request.\nLuckily for us, other people have dealt with this problem for a long time and\nwe now have some pretty nice ways of handling it.\nStarting with handling how we'll be making an HTTP request, we'll use a\nlibrary (called fetch , which is also a web standard\n(https://fetch.spec.whatwg.org/), hopefully) to make the http requesting\neasier to deal with.\n\nFetch\nIn order to use fetch, we'll need to install the library in our app we previously\ncreated. Let's open up a terminal window again and use npm to install the\nwhatwg-fetch library (an implementation of fetch ). In the same directory\nwhere we created our application, let's call:\n\nnpm install --save whatwg-fetch\n\n146","metadata":{"loc":{"lines":{"from":4397,"to":4416}}}}],["156",{"pageContent":"npm install --save whatwg-fetch\n\n146\n\n\fWith the library installed, we can make a request to an off-site server. In\norder to get access to the fetch library, we'll need to import the package in\nour script. Let's update the top few lines of our src/App.js file adding the\nsecond line:\n\nimport React, { Component } from \"react\";\nimport \"whatwg-fetch\";\n// ...\n\nThe whatwg-fetch object is unique in that it is one of the few\nlibraries that we'll use which attaches it's export on the\nglobal object (in the case of the browser, this object is\nwindow ). Unlike the react library, we don't need to get a\nhandle on it's export as the library makes it available on the\nglobal object.\n\nWith the whatwg-fetch library included in our project, we can make a request\nusing the fetch() api. However, before we can actually start using the\nfetch() api, we'll need to understand what Promises are and how they work","metadata":{"loc":{"lines":{"from":4416,"to":4438}}}}],["157",{"pageContent":"to deal with the asynchronous we discussed in the introduction.\nWe'll pick up with promises tomorrow. Good job getting through week two\nand see you tomorrow!\n\n147\n\n\fIntroduction to Promises\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-15/post.md)\n\nToday, we're going to look at what we need to know to\nunderstand Promises from a high-level, so we can build our\napplications using this incredibly useful concept.\nYesterday (/articles/30-days-of-react-day-14/) we installed the fetch\nlibrary into our create-react-app project we started on day 12 (/articles/30days-of-react-day-12/). Today we'll pick up from yesterday discussing the\nconcept and the art of Promises (https://developer.mozilla.org/enUS/docs/Web/JavaScript/Reference/Global_Objects/Promise).","metadata":{"loc":{"lines":{"from":4440,"to":4454}}}}],["158",{"pageContent":"What is a promise\nAs defined by the Mozilla, a Promise object is used for handling\nasynchronous computations which has some important guarantees that are\ndifficult to handle with the callback method (the more old-school method of\nhandling asynchronous code).\nA Promise object is simply a wrapper around a value that may or may not be\nknown when the object is instantiated and provides a method for handling\nthe value after it is known (also known as resolved ) or is unavailable for a\nfailure reason (we'll refer to this as rejected ).\nUsing a Promise object gives us the opportunity to associate functionality for\nan asynchronous operation's eventual success or failure (for whatever\nreason). It also allows us to treat these complex scenarios by using\n148\n\n\fsynchronous-like code.\nFor instance, consider the following synchronous code where we print out\nthe current time in the JavaScript console:\n\nvar currentTime = new Date();\nconsole.log('The current time is: ' + currentTime);","metadata":{"loc":{"lines":{"from":4456,"to":4475}}}}],["159",{"pageContent":"var currentTime = new Date();\nconsole.log('The current time is: ' + currentTime);\n\nThis is pretty straight-forward and works as the new Date() object\nrepresents the time the browser knows about. Now consider that we're using\na different clock on some other remote machine. For instance, if we're\nmaking a Happy New Years clock, it would be great to be able to synchronize\nthe user's browser with everyone elses using a single time value for everyone\nso no-one misses the ball dropping ceremony.\nSuppose we have a method that handles getting the current time for the\nclock called getCurrentTime() that fetches the current time from a remote\nserver. We'll represent this now with a setTimeout() that returns the time\n(like it's making a request to a slow API):\n\nfunction getCurrentTime() {\n// Get the current 'global' time from an API\nreturn setTimeout(function() {\nreturn new Date();\n}, 2000);\n}\nvar currentTime = getCurrentTime()\nconsole.log('The current time is: ' + currentTime);","metadata":{"loc":{"lines":{"from":4475,"to":4496}}}}],["160",{"pageContent":"Our console.log() log value will return the timeout handler id, which is\ndefinitely not the current time. Traditionally, we can update the code using a\ncallback to get called when the time is available:\n\n149\n\n\ffunction getCurrentTime(callback) {\n// Get the current 'global' time from an API\nreturn setTimeout(function() {\nvar currentTime = new Date();\ncallback(currentTime);\n}, 2000);\n}\ngetCurrentTime(function(currentTime) {\nconsole.log('The current time is: ' + currentTime);\n});\n\nWhat if there is an error with the rest? How do we catch the error and define\na retry or error state?","metadata":{"loc":{"lines":{"from":4498,"to":4516}}}}],["161",{"pageContent":"What if there is an error with the rest? How do we catch the error and define\na retry or error state?\n\nfunction getCurrentTime(onSuccess, onFail) {\n// Get the current 'global' time from an API\nreturn setTimeout(function() {\n// randomly decide if the date is retrieved or not\nvar didSucceed = Math.random() >= 0.5;\nif (didSucceed) {\nvar currentTime = new Date();\nonSuccess(currentTime);\n} else {\nonFail('Unknown error');\n}\n}, 2000);\n}\ngetCurrentTime(function(currentTime) {\nconsole.log('The current time is: ' + currentTime);\n}, function(error) {\nconsole.log('There was an error fetching the time');\n});\n\nNow, what if we want to make a request based upon the first request's value?\nAs a short example, let's reuse the getCurrentTime() function inside again (as\nthough it were a second method, but allows us to avoid adding another\ncomplex-looking function):\n\n150","metadata":{"loc":{"lines":{"from":4516,"to":4543}}}}],["162",{"pageContent":"150\n\n\ffunction getCurrentTime(onSuccess, onFail) {\n// Get the current 'global' time from an API\nreturn setTimeout(function() {\n// randomly decide if the date is retrieved or not\nvar didSucceed = Math.random() >= 0.5;\nconsole.log(didSucceed);\nif (didSucceed) {\nvar currentTime = new Date();\nonSuccess(currentTime);\n} else {\nonFail('Unknown error');\n}\n}, 2000);\n}\ngetCurrentTime(function(currentTime) {\ngetCurrentTime(function(newCurrentTime) {\nconsole.log('The real current time is: ' + currentTime);\n}, function(nestedError) {\nconsole.log('There was an error fetching the second time');\n})\n}, function(error) {\nconsole.log('There was an error fetching the time');\n});\n\nDealing with asynchronousity in this way can get complex quickly. In\naddition, we could be fetching values from a previous function call, what if we\nonly want to get one... there are a lot of tricky cases to deal with when\ndealing with values that are not yet available when our app starts.","metadata":{"loc":{"lines":{"from":4543,"to":4572}}}}],["163",{"pageContent":"Enter Promises\nUsing promises, on the other hand helps us avoid a lot of this complexity\n(although is not a silver bullet solution). The previous code, which could be\ncalled spaghetti code can be turned into a neater, more synchronous-looking\nversion:\n\n151\n\n\ffunction getCurrentTime() {\n// Get the current 'global' time from an API using Promise\nreturn new Promise((resolve, reject) => {\nsetTimeout(function() {\nvar didSucceed = Math.random() >= 0.5;\ndidSucceed ? resolve(new Date()) : reject('Error');\n}, 2000);\n})\n}\ngetCurrentTime()\n.then(currentTime => getCurrentTime())\n.then(currentTime => {\nconsole.log('The current time is: ' + currentTime);\nreturn true;\n})\n.catch(err => console.log('There was an error:' + err))\n\nThis previous source example is a bit cleaner and clear as to what's going on\nand avoids a lot of tricky error handling/catching.\nTo catch the value on success, we'll use the then() function available on the\nPromise instance object. The then() function is called with whatever the","metadata":{"loc":{"lines":{"from":4574,"to":4602}}}}],["164",{"pageContent":"return value is of the promise itself. For instance, in the example above, the\ngetCurrentTime() function resolves with the currentTime() value (on\nsuccessful completion) and calls the then() function on the return value\n(which is another promise) and so on and so forth.\nTo catch an error that occurs anywhere in the promise chain, we can use the\ncatch() method.\n\n152\n\n\fWe're using a promise chain in the above example to create a\nchain of actions to be called one after another. A promise\nchain sounds complex, but it's fundamentally simple.\nEssentially, we can \"synchronize\" a call to multiple\nasynchronous operations in succession. Each call to then() is\ncalled with the previous then() function's return value.\nFor instance, if we wanted to manipulate the value of the\ngetCurrentTime() call, we can add a link in the chain, like so:","metadata":{"loc":{"lines":{"from":4604,"to":4620}}}}],["165",{"pageContent":"getCurrentTime()\n.then(currentTime => getCurrentTime())\n.then(currentTime => {\nreturn 'It is now: ' + currentTime;\n})\n// this logs: \"It is now: [current time]\"\n.then(currentTimeMessage => console.log(currentTimeMessage))\n.catch(err => console.log('There was an error:' + err))\n\nSingle-use guarantee\nA promise only ever has one of three states at any given time:\npending\nfulfilled (resolved)\nrejected (error)\nA pending promise can only ever lead to either a fulfilled state or a rejected\nstate once and only once, which can avoid some pretty complex error\nscenarios. This means that we can only ever return a promise once. If we\nwant to rerun a function that uses promises, we need to create a new one.\n\nCreating a promise\n153","metadata":{"loc":{"lines":{"from":4622,"to":4642}}}}],["166",{"pageContent":"Creating a promise\n153\n\n\fWe can create new promises (as the example shows above) using the Promise\nconstructor. It accepts a function that will get run with two parameters:\nThe onSuccess (or resolve ) function to be called on success resolution\nThe onFail (or reject ) function to be called on failure rejection\nRecalling our function from above, we can see that we call the resolve()\nfunction if the request succeeded and call the reject() function if the\nmethod returns an error condition.\n\nvar promise = new Promise(function(resolve, reject) {\n// call resolve if the method succeeds\nresolve(true);\n})\npromise.then(bool => console.log('Bool is true'))\n\nNow that we know what promises are, how to use, and how to create them,\nwe can actually get down to using the fetch() library we installed yesterday.\ndd\n\n154\n\n\fDisplaying Remote Data\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-16/post.md)","metadata":{"loc":{"lines":{"from":4642,"to":4666}}}}],["167",{"pageContent":"154\n\n\fDisplaying Remote Data\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-16/post.md)\n\nOur front-end applications are only as interesting as the data we\ndisplay in them. Today, let's actually start making a request for\ndata and get it integrated into our app.\nAs of today, we've worked through promises, built our app using the npm\npackager, installed our remote object fetching library ( whatwg-fetch ) and\nwe're finally ready to integrate remote data into our application.\n\nFetching data\nLet's get into using the fetch library we installed on day 14 (/articles/30days-of-react/14-ajax).\nFor simplicity purposes, let's break out our demo from yesterday where we\nfetched the current time from an API server:\n\nGet the current time\nPST\n\nA chronic string messageUpdate\n(such as\nrequest\n7 hours from now)\n\nWe'll be making a request from:\n\n155","metadata":{"loc":{"lines":{"from":4666,"to":4693}}}}],["168",{"pageContent":"Get the current time\nPST\n\nA chronic string messageUpdate\n(such as\nrequest\n7 hours from now)\n\nWe'll be making a request from:\n\n155\n\n\fThis demo react component makes a request to the API server and reports\nback the current time from it's clock. Before we add the call to fetch, let's\ncreate a few stateful components we'll use to display the time and update the\ntime request.\n\nWalls of code warning\nWe realize the next few lines are walls of code, which we generally try to\navoid, especially without discussing how they work. However, since we're\nnot talking about how to create a component in detail here, yet we still\nwant to fill out a complete component, we've made an exception.\nPlease leave us feedback (links at the bottom) if you prefer us to change\nthis approach for today.\n\nFirst, the basis of the wrapper component which will show and fetch the\ncurrent time looks like the following. Let's copy and paste this code into our\napp at src/App.js :\n\n156","metadata":{"loc":{"lines":{"from":4693,"to":4722}}}}],["169",{"pageContent":"156\n\n\fimport React from 'react';\nimport 'whatwg-fetch';\nimport './App.css';\nimport TimeForm from './TimeForm';\nclass App extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.fetchCurrentTime = this.fetchCurrentTime.bind(this);\nthis.handleFormSubmit = this.handleFormSubmit.bind(this);\nthis.handleChange = this.handleChange.bind(this);\nthis.state = {\ncurrentTime: null, msg: 'now'\n}\n}\n// methods we'll fill in shortly\nfetchCurrentTime() {}\ngetApiUrl() {}\nhandleFormSubmit(evt) {}\nhandleChange(newState) {}\nrender() {\nconst {currentTime, tz} = this.state;\nconst apiUrl = this.getApiUrl();\nreturn (\n<div>\n{!currentTime &&\n<button onClick={this.fetchCurrentTime}>\nGet the current time\n</button>}\n{currentTime && <div>The current time is: {currentTime}</div>}\n<TimeForm\nonFormSubmit={this.handleFormSubmit}\nonFormChange={this.handleChange}\ntz={tz}\nmsg={'now'}\n/>\n<p>We'll be making a request from: <code>{apiUrl}</code></p>\n157\n\n\f</div>\n)\n}\n}\nexport default App;","metadata":{"loc":{"lines":{"from":4722,"to":4766}}}}],["170",{"pageContent":"</div>\n)\n}\n}\nexport default App;\n\nThe previous component is a basic stateful React component as we've\ncreated. Since we'll want to show a form, we've included the intended usage\nof the TimeForm let's create next.\nLet's create this component in our react app using create-react-app . Add\nthe file src/TimeForm.js into our project:\n\ntouch src/TimeForm.js\n\nNow let's add content. We'll want our TimeForm to take the role of allowing\nthe user to switch between timezones in their browser. We can handle this\nby creating a stateful component we'll call the TimeForm . Our TimeForm\ncomponent might look like the following:\n\n158","metadata":{"loc":{"lines":{"from":4766,"to":4785}}}}],["171",{"pageContent":"158\n\n\fimport React from 'react'\nconst timezones = ['PST', 'MST', 'MDT', 'EST', 'UTC']\nexport class TimeForm extends React.Component {\nconstructor(props) {\nsuper(props);\nthis._changeTimezone = this._changeTimezone.bind(this);\nthis._handleFormSubmit = this._handleFormSubmit.bind(this);\nthis._handleChange = this._handleChange.bind(this);\nthis._changeMsg = this._changeMsg.bind(this);\nconst {tz, msg} = this.props;\nthis.state = {tz, msg};\n}\n_handleChange(evt) {\ntypeof this.props.onFormChange === 'function' &&\nthis.props.onFormChange(this.state);\n}\n_changeTimezone(evt) {\nconst tz = evt.target.value;\nthis.setState({tz}, this._handleChange);\n}\n_changeMsg(evt) {\nconst msg =\nencodeURIComponent(evt.target.value).replace(/%20/g, '+');\nthis.setState({msg}, this._handleChange);\n}\n_handleFormSubmit(evt) {\nevt.preventDefault();\ntypeof this.props.onFormSubmit === 'function' &&\nthis.props.onFormSubmit(this.state);\n}\nrender() {\nconst {tz} = this.state;\nreturn (\n159","metadata":{"loc":{"lines":{"from":4785,"to":4820}}}}],["172",{"pageContent":"<form onSubmit={this._handleFormSubmit}>\n<select\nonChange={this._changeTimezone}\ndefaultValue={tz}>\n{timezones.map(t => {\nreturn (<option key={t} value={t}>{t}</option>)\n})}\n</select>\n<input\ntype=\"text\"\nplaceholder=\"A chronic string message (such as 7 hours from\nnow)\"\nonChange={this._changeMsg}\n/>\n<input\ntype=\"submit\"\nvalue=\"Update request\"\n/>\n</form>\n)\n}\n}\nexport default TimeForm;\n\nWith these Components created, let's load up our app in the browser after\nrunning it with npm start and we'll see our form (albeit not incredibly\nbeautiful yet). Of course, at this point, we won't have a running component as\nwe haven't implemented our data fetching. Let's get to that now.\n\nGet the current time\nPST\n\nA chronic string messageUpdate\n(such as\nrequest\n7 hours from now)\n\nWe'll be making a request from:\n\nFetching data\n\n160","metadata":{"loc":{"lines":{"from":4822,"to":4863}}}}],["173",{"pageContent":"Get the current time\nPST\n\nA chronic string messageUpdate\n(such as\nrequest\n7 hours from now)\n\nWe'll be making a request from:\n\nFetching data\n\n160\n\n\fFetching data\nAs we said yesterday, we'll use the fetch() API with promise support. When\nwe call the fetch() method, it will return us a promise, where we can handle\nthe request however we want. We're going to make a request to our nowbased API server (so start-up might be slow if it hasn't been run in a while).\nWe're going to be building up the URL we'll request as it represents the time\nquery we'll request on the server.\nI've already defined the method getApiUrl() in the App component, so let's\nfill that function in.\nThe chronic api server accepts a few variables that we'll customize in the\nform. It will take the timezone to along with a chronic message. We'll start\nsimply and ask the chronic library for the pst timezone and the current time\n( now ):","metadata":{"loc":{"lines":{"from":4863,"to":4888}}}}],["174",{"pageContent":"class App extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\ncurrentTime: null, msg: 'now', tz: 'PST'\n}\n}\n// ...\ngetApiUrl() {\nconst {tz, msg} = this.state;\nconst host = 'https://andthetimeis.com';\nreturn host + '/' + tz + '/' + msg + '.json';\n}\n// ...\nexport default App;\n\nNow, when we call getApiUrl() , the URL of the next request will be returned\nfor us. Now, finally, let's implement our fetch() function. The fetch()\nfunction accepts a few arguments that can help us customize our requests.\n\n161","metadata":{"loc":{"lines":{"from":4890,"to":4910}}}}],["175",{"pageContent":"161\n\n\fThe most basic GET request can just take a single URL endpoint. The return\nvalue on fetch() is a promise object, that we explored in-depth yesterday.\nLet's update our fetchCurrentTime() method to fetch the current time from\nthe remote server. We'll use the .json() method on the response object to\nturn the body of the response from a JSON object into JavaScript object and\nthen update our component by setting the response value of the dateString\nas the currentTime in the component state:\n\nclass App extends React.Component {\n// ...\nfetchCurrentTime() {\nfetch(this.getApiUrl())\n.then(resp => resp.json())\n.then(resp => {\nconst currentTime = resp.dateString;\nthis.setState({currentTime})\n})\n}\n// ...\n}","metadata":{"loc":{"lines":{"from":4910,"to":4931}}}}],["176",{"pageContent":"The final piece of our project today is getting the data back from the form to\nupdate the parent component. That is, when the user updates the values\nfrom the TimeForm component, we'll want to be able to access the data in the\nApp component. The TimeForm component already handles this process for\nus, so we just need to implement our form functions.\nWhen a piece of state changes on the form component, it will call a prop\ncalled onFormChange . By defining this method in our App component, we can\nget access to the latest version of the form.\nIn fact, we'll just call setState() to keep track of the options the form allows\nthe user to manipulate:\n\n162\n\n\fclass App extends React.Component {\n// ...\nhandleChange(newState) {\nthis.setState(newState);\n}\n// ...\n}","metadata":{"loc":{"lines":{"from":4933,"to":4952}}}}],["177",{"pageContent":"162\n\n\fclass App extends React.Component {\n// ...\nhandleChange(newState) {\nthis.setState(newState);\n}\n// ...\n}\n\nFinally, when the user submits the form (clicks on the button or presses enter\nin the input field), we'll want to make another request for the time. This\nmeans we can define our handleFormSubmit prop to just call the\nfetchCurrentTime() method:\n\nclass App extends React.Component {\n// ...\nhandleFormSubmit(evt) {\nthis.fetchCurrentTime();\n}\n// ...\n}\n\nGet the current time\nPST\n\nA chronic string messageUpdate\n(such as\nrequest\n7 hours from now)","metadata":{"loc":{"lines":{"from":4952,"to":4981}}}}],["178",{"pageContent":"class App extends React.Component {\n// ...\nhandleFormSubmit(evt) {\nthis.fetchCurrentTime();\n}\n// ...\n}\n\nGet the current time\nPST\n\nA chronic string messageUpdate\n(such as\nrequest\n7 hours from now)\n\nWe'll be making a request from: https://andthetimeis.com/PST/now.json\nTry playing around with the demo and passing in different chronic options.\nIt's actually quite fun.\nIn any case, today we worked on quite a bit to get remote data into our app.\nHowever, at this point, we only have a single page in our single page app.\nWhat if we want to show a different page in our app? Tomorrow, we're going\nto start adding multiple pages in our app so we can feature different views.\n\n163\n\n\f164\n\n\fClient-side Routing\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-17/post.md)","metadata":{"loc":{"lines":{"from":4981,"to":5010}}}}],["179",{"pageContent":"Most, if not all of our applications will have multiple views in our\nsingle-page application. Let's dive right into creating multiple\nviews for our applications using React Router.\nWe've made it through 16 days already! Pat yourself on the back... but not for\ntoo long... there is still a lot more.\nRight now, our app is limited to a single page. It's pretty rare to find any\ncomplex application that shows a single view. For instance, an application\nmight have a login view where a user can log in or a search results page that\nshows a user a list of their search results. These are two different views with\ntwo different page structures.\nLet's see how we can change that with our app today.\nWe'll use the very popular react-router (https://github.com/reactjs/reactrouter) library for handling different links. In order to use the react-router\nlibrary, we'll need to install it using the npm package manager:\n\nnpm install --save react-router-dom\n\n165","metadata":{"loc":{"lines":{"from":5012,"to":5028}}}}],["180",{"pageContent":"With react-router installed, we'll import a few packages from the library and\nupdate our app architecture. Before we make those updates, let's take a step\nback and from a high level look at how and why we architect our application\nthis way.\nConceptually with React, we've seen how we can create tree structures using\ncomponents and nested components. Using this perspective with a single\npage app with routes, we can think of the different parts of a page as\nchildren. Routing in a single page app from this perspective is the idea that\nwe can take a part of a subtree and switch it out with another subtree. We\ncan then dynamically switch out the different trees in the browser.\nIn other words, we'll define a React component that acts as a root component\nof the routable elements. We can then tell React to change a view, which can\njust swap out an entire React component for another one as though it's a\ncompletely different page rendered by a server.","metadata":{"loc":{"lines":{"from":5030,"to":5043}}}}],["181",{"pageContent":"of the routable elements. We can then tell React to change a view, which can\njust swap out an entire React component for another one as though it's a\ncompletely different page rendered by a server.\nWe'll take our App component and define all of the different routes we can\nmake in our app in this App component. We'll need to pull some components\nfrom the react-router package. These components we'll use to set up this\nstructure are as follows:","metadata":{"loc":{"lines":{"from":5043,"to":5049}}}}],["182",{"pageContent":"<BrowserRouter /> / <Router />\n166\n\n\fThis is the component we'll use to define the root or the routing tree. The\n<BrowserRouter /> component is the component where React will replace it's\nchildren on a per-route basis.\n\n<Route />\nWe'll use the <Route /> component to create a route available at a specific\nlocation available at a url. The <Route /> component is mounted at page\nURLs that match a particular route set up in the route's configuration props .\nOne older, compatible way of handling client-side navigation is to use the #\n(hash) mark denoting the application endpoint. We'll use this method. We'll\nneed this object imported to tell the browser this is how we want to handle\nour navigation.\nFrom the app we created a few days ago's root directory, let's update our\nsrc/App.js to import these modules. We'll import the BrowserRouter using a\ndifferent name syntax via ES6:","metadata":{"loc":{"lines":{"from":5051,"to":5068}}}}],["183",{"pageContent":"import React from \"react\";\nimport { BrowserRouter as Router, Route } from \"react-router-dom\";\nexport class App extends React.Component {\nrender() {\n<Router>{/* routes will go here */}</Router>;\n}\n}\n\nNow let's define our first route. To define a route, we'll use the <Route />\ncomponent export from react-router and pass it a few props:\npath - The path for the route to be active\ncomponent - The component that defines the view of the route\n\nLet's define the a route at the root path / with a stateless component that\njust displays some static content:\n167\n\n\fconst Home = () => (\n<div>\n<h1>Welcome home</h1>\n</div>\n);\n// ...\nclass App extends React.Component {\nrender() {\nreturn (\n<Router>\n<Route path=\"/\" component={Home} />\n</Router>\n);\n}\n}\n\nWelcome home\n\nLoading this page in the browser, we can see we get our single route at the\nroot url. Not very exciting. Let's add a second route that shows an about page\nat the /about URL.\n\n168","metadata":{"loc":{"lines":{"from":5070,"to":5109}}}}],["184",{"pageContent":"Welcome home\n\nLoading this page in the browser, we can see we get our single route at the\nroot url. Not very exciting. Let's add a second route that shows an about page\nat the /about URL.\n\n168\n\n\fconst Home = () => (\n<div>\n<h1>Welcome home</h1>\n</div>\n);\n// ...\nclass App extends React.Component {\nrender() {\nreturn (\n<Router>\n<div>\n<Route path=\"/\" component={Home} />\n<Route path=\"/about\" component={About} />\n</div>\n</Router>\n);\n}\n}\n\nWelcome home\n\nIn our view we'll need to add a link (or an anchor tag -- <a /> ) to enable our\nusers to travel freely between the two different routes. However, using the\n<a /> tag will tell the browser to treat the route like it's a server-side route.\n\nInstead, we'll need to use a different component (surprise) called: <Link /> .\nThe <Link /> component requires a prop called to to point to the clientside route where we want to render. Let's update our Home and About\ncomponents to use the Link :\n169","metadata":{"loc":{"lines":{"from":5109,"to":5145}}}}],["185",{"pageContent":"import { BrowserRouter as Router, Route, Link } from \"react-routerdom\";\nconst Home = () => (\n<div>\n<h1>Welcome home</h1>\n<Link to=\"/about\">Go to about</Link>\n</div>\n);\nconst About = () => (\n<div>\n<h1>About</h1>\n<Link to=\"/\">Go home</Link>\n</div>\n);\n// ...\n\nWelcome home\nGo to about\n\nWait a minute... we don't quite want both routes to show up... This happens\nbecause the react router will render all content that matches the path (unless\notherwise specified). For this case, react router supplies us with the Switch\ncomponent.\nThe <Switch /> component will only render the first matching route it finds.\nLet's update our component to use the Switch component. As react router\nwill try to render both components, we'll need to specify that we only want an\nexact match on the root component.\n170","metadata":{"loc":{"lines":{"from":5147,"to":5173}}}}],["186",{"pageContent":"import { BrowserRouter as Router, Route, Link, Switch } from \"reactrouter-dom\";\n// ...\nconst Home = () => (\n<div>\n<h1>Welcome home</h1>\n<Link to=\"/about\">Go to about</Link>\n</div>\n);\n// ...\nclass App extends React.Component {\nrender() {\nreturn (\n<Router>\n<Switch>\n<Route path=\"/about\" component={About} />\n<Route path=\"/\" component={Home} />\n</Switch>\n</Router>\n);\n}\n}\n\nWelcome home\nGo to about\n\nShowing views\n171","metadata":{"loc":{"lines":{"from":5175,"to":5201}}}}],["187",{"pageContent":"Welcome home\nGo to about\n\nShowing views\n171\n\n\fAlthough this is a limited introduction, we could not leave the discussion of\ndealing with react router without talking about the different ways we can get\nsubcomponents to render.\nWe've already seen the simplest way possible, using the component prop,\nhowever there is a more powerful method using a prop called render . The\nrender prop is expected to be a function that will be called with the match\nobject along with the location and route configuration.\nThe render prop allows us to render whatever we want in a subroute, which\nincludes rendering other routes. Nifty, ey? Let's see this in action:\n\n172","metadata":{"loc":{"lines":{"from":5201,"to":5217}}}}],["188",{"pageContent":"172\n\n\fconst Home = () => (\n<div>\n<h1>Welcome home</h1>\n<Link to=\"/about\">Go to about</Link>\n</div>\n);\nconst About = ({ name }) => (\n<div>\n<h1>About {name}</h1>\n</div>\n);\n// ...\nclass App extends React.Component {\nrender() {\nreturn (\n<Router>\n<Switch>\n<Route\npath=\"/about\"\nrender={renderProps => (\n<div>\n<Link to=\"/about/ari\">Ari</Link>\n<Link to=\"/about/nate\">Nate</Link>\n<Route\npath=\"/about/:name\"\nrender={renderProps => (\n<div>\n<About name={renderProps.match.params.name} />\n<Link to=\"/\">Go home</Link>\n</div>\n)}\n/>\n</div>\n)}\n/>\n<Route\npath=\"/\"\nrender={renderProps => (\n<div>\nHome is underneath me\n<Home {...this.props} {...renderProps} />\n</div>\n173\n\n\f)}\n/>\n</Switch>\n</Router>\n);\n}\n}\n\nHome is underneath me\n\nWelcome home\nGo to about\n\nNow we have multiple pages in our application. We've looked at how we can\nrender these routes through nested components with just a few of the\nexports from react-router .\nreact-router provides so much more functionality that we don't have time","metadata":{"loc":{"lines":{"from":5217,"to":5279}}}}],["189",{"pageContent":"to cover in our brisk intro to routing. More information is available at:\nhttps://github.com/reactjs/react-router/tree/master/docs\n(https://github.com/reactjs/react-router/tree/master/docs)\nfullstack react routing (https://fullstackreact.com)\nTomorrow, we're going to be starting integration with Redux. Here's where\nwe start integrating more complex data handling.\n\n174\n\n\f175\n\n\fIntroduction to Flux\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-18/post.md)","metadata":{"loc":{"lines":{"from":5281,"to":5293}}}}],["190",{"pageContent":"174\n\n\f175\n\n\fIntroduction to Flux\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-18/post.md)\n\nHandling data inside a client-side application is a complex task.\nToday we're looking at a one method of handling complex data\nproposed by Facebook called the Flux Architecture.\nAs our applications get bigger and more complex, we'll need a better data\nhandling approach. With more data, we'll have more to keep track of.\nOur code is required to handle more data and application state with new\nfeatures. From asynchronous server responses to locally-generated,\nunsynchronized data, we have to not only keep track of this data, but also tie\nit to the view in a sane way.\nRecognizing this need for data management, the Facebook team released a\npattern for dealing with data called Flux\n(https://facebook.github.io/flux/docs/overview.html).\nToday, we're going to take a look at the Flux architecture, what it is and why\nit exists.","metadata":{"loc":{"lines":{"from":5293,"to":5313}}}}],["191",{"pageContent":"What is flux\nFlux is a pattern for managing how data flows through a React application. As\nwe've seen, the preferred method of working with React components is\nthrough passing data from one parent component to it's children\n176\n\n\fcomponents. The Flux pattern makes this model the default method for\nhandling data.\nThere are three distinct roles for dealing with data in the flux methodology:\nDispatcher\nStores\nViews (our components)\nThe major idea behind Flux is that there is a single-source of truth (the\nstores) and they can only be updated by triggering actions. The actions are\nresponsible for calling the dispatcher, which the stores can subscribe for\nchanges and update their own data accordingly.\nWhen a dispatch has been triggered, and the store updates, it will emit a\nchange event which the views can rerender accordingly.","metadata":{"loc":{"lines":{"from":5315,"to":5332}}}}],["192",{"pageContent":"This may seem unnecessarily complex, but the structure makes it incredibly\neasy to reason about where our data is coming from, what causes it's\nchanges, how it changes, and lets us track specific user flows, etc.\nThe key idea behind Flux is:\nData flows in one direction and kept entirely in the stores.\n\nImplementations\nAlthough we can create our own flux implementation, many have already\ncreated some fantastic libraries we can pick from.\nFacebook's flux (https://github.com/facebook/flux)\n177\n\n\falt (http://alt.js.org/)\nnuclear-js (https://optimizely.github.io/nuclear-js/)\nFluxible (http://fluxible.io/)\nreflux (https://github.com/reflux/refluxjs)\nFluxxor (http://fluxxor.com/)\nflux-react (https://github.com/christianalfoni/flux-react)\nAnd more... many many more\n\nPlug for fullstackreact\nWe discuss this material in-depth about Flux, using libraries, and even\nimplementing our own version of flux that suits us best. Check it out at\nfullstackreact.com (https://fullstackreact.com)","metadata":{"loc":{"lines":{"from":5334,"to":5357}}}}],["193",{"pageContent":"It can be pretty intense trying to pick the right choice for our applications.\nEach has their own features and are great for different reasons. However, to a\nlarge extent, the React community has focused in on using another flux tool\ncalled Redux (http://redux.js.org/).\n\nRedux (http://redux.js.org/)\nRedux is a small-ish library that takes it's design inspiration from the Flux\npattern, but is not itself a pure flux implementation. It provides the same\ngeneral principles around how to update the data in our application, but in\nslightly different way.\nUnlike Flux, Redux does not use a dispatcher, but instead it uses pure\nfunctions to define data mutating functions. It still uses stores and actions,\nwhich can be tied directly to React components.\nThe 3 major principles\n(http://redux.js.org/docs/introduction/ThreePrinciples.html) of Redux we'll\nkeep in mind as we implement Redux in our app are:\n\n178","metadata":{"loc":{"lines":{"from":5359,"to":5376}}}}],["194",{"pageContent":"178\n\n\fUpdates are made with pure functions (in reducers)\nstate is a read-only property\nstate is the single source of truth (there is only one store in a Redux\napp)\nOne big difference with Redux and Flux is the concept of middleware. Redux\nadded the idea of middleware that we can use to manipulate actions as we\nreceive them, both coming in and heading out of our application. We'll\ndiscuss them in further detail in a few days.\nIn any case, this is a lot of introduction to the flux pattern. Tomorrow we'll\nactually start moving our data to use Redux.\n\n179\n\n\fData Management with Redux\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-19/post.md)","metadata":{"loc":{"lines":{"from":5376,"to":5392}}}}],["195",{"pageContent":"179\n\n\fData Management with Redux\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-19/post.md)\n\nWith the knowledge of flux and Redux, let's integrate Redux in\nour application and walk through connected applications.\nYesterday, we discussed (in light detail) the reason for the Flux pattern, what\nit is, the different options we have available to us, as well as introduced Redux\n(http://redux.js.org/).\nToday, we are going to get back to code and on to adding Redux in our app.\nThe app we're building with it right now is bare-bones simple, which will just\nshow us the last time the page fetched the current time. For simplicity for\nnow, we won't call out to a remote server, just using the JavaScript Date\nobject.\nThe first thing we'll have to do to use Redux is install the library. We can use\nthe npm package manager to install redux . In the root directory of our app\nwe previously built, let's run the npm install command to install redux:","metadata":{"loc":{"lines":{"from":5392,"to":5409}}}}],["196",{"pageContent":"npm install --save redux\n\nWe'll also need to install another package that we'll use with redux, the\nreact-redux that will help us tie together react and redux :\n\nnpm install --save react-redux\n\n180\n\n\fConfiguration and setup\nThe next bit of work we need to do is to set up Redux inside of our app. We'll\nneed to do the following to get it set up:\n1. Define reducers\n2. Create a store\n3. Create action creators\n4. Tie the store to our React views\n5. Profit\n\nNo promises on step 5, but it would be nice, eh?\n\nPrecursor\nWe'll talk terminology as we go, so take this setup discussion lightly\n(implementing is more important to get our fingers moving). We'll\nrestructure our app just slightly (annoying, I know... but this is the last time)\n181\n\n\fso we can create a wrapper component to provide data down through our\napp.\nWhen we're complete, our app tree will have the following shape:\n[Root] -> [App] -> [Router/Routes] -> [Component]","metadata":{"loc":{"lines":{"from":5411,"to":5440}}}}],["197",{"pageContent":"so we can create a wrapper component to provide data down through our\napp.\nWhen we're complete, our app tree will have the following shape:\n[Root] -> [App] -> [Router/Routes] -> [Component]\n\nWithout delaying any longer, let's move our src/App.js into the\nsrc/containers directory and we'll need to update some of the paths from\n\nour imports at the same time. We'll be using the react router material we\ndiscussed a few days ago.\nWe'll include a few routes with the <Switch /> statement to ensure only one\nshows up at a time.\n\nimport React from \"react\";\nimport { BrowserRouter as Router, Route, Switch } from \"react-routerdom\";\n// We'll load our views from the `src/views`\n// directory\nimport Home from \"./views/Home/Home\";\nimport About from \"./views/About/About\";\nconst App = props => {\nreturn (\n<Router>\n<Switch>\n<Route path=\"/about\" component={About} />\n<Route path=\"*\" component={Home} />\n</Switch>\n</Router>\n);\n};\nexport default App;\n\n182","metadata":{"loc":{"lines":{"from":5440,"to":5471}}}}],["198",{"pageContent":"182\n\n\fIn addition, we'll need to create a new container we'll call Root which will\nwrap our entire <App /> component and make the store available to the rest\nof the app. Let's create the src/containers/Root.js file:\n\ntouch src/containers/Root.js\n\nFor the time being, we'll use a placeholder component here, but we'll replace\nthis content as we talk about the store. For now, let's export something:\n\nimport React from \"react\";\nimport App from \"./App\";\nconst Root = props => {\nreturn <App />;\n};\nexport default Root;\n\nFinally, let's update the route that we render our app in the src/index.js file\nto use our new Root container instead of the App it previously used.\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Root from \"./containers/Root\";\nimport \"./index.css\";\nReactDOM.render(<Root />, document.getElementById(\"root\"));","metadata":{"loc":{"lines":{"from":5471,"to":5496}}}}],["199",{"pageContent":"import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Root from \"./containers/Root\";\nimport \"./index.css\";\nReactDOM.render(<Root />, document.getElementById(\"root\"));\n\nAdding in Redux\nNow with a solid app structure in place, we can start to add in Redux. The\nsteps we'll take to tie in some Redux structure are generally all the same for\nmost every application we'll build. We'll need to:\n1. Write a root reducer\n2. Write actionCreators\n\n183\n\n\f3. Configure the store with the rootReducer, the store, and the app\n4. Connect the views to the actionCreators\nWe'll purposefully be keeping this high-level introduction a tad short, so hang\ntight if that's a mouthful, it will all make more sense shortly.\nLet's setup the structure to allow us to add redux. We'll do almost all of our\nwork in a src/redux directory. Let's create that directory.\n\nmkdir -p src/redux\ntouch src/redux/configureStore.js\ntouch src/redux/reducers.js","metadata":{"loc":{"lines":{"from":5496,"to":5520}}}}],["200",{"pageContent":"mkdir -p src/redux\ntouch src/redux/configureStore.js\ntouch src/redux/reducers.js\n\nLet's start by creating our reducer first. Although it sounds complex, a\nreducer is actually pretty straight-forward with some experience. A reducer\nis literally only a function. It's sole responsibility is to return a representation\nof the next state.\nIn the Redux pattern, unlike flux we are only handling one global store for the\nentire application. This makes things much easier to deal with as there's a\nsingle place for the data of our application to live.\nThe root reducer function is responsible to return a representation of the\ncurrent global state of the application. When we dispatch an action on the\nstore, this reducer function will be called with the current state of the\napplication and the action that causes the state to update.\nLet's build our root reducer in a file at src/redux/reducers.js .\n\n184","metadata":{"loc":{"lines":{"from":5520,"to":5537}}}}],["201",{"pageContent":"184\n\n\f// Initial (starting) state\nexport const initialState = {\ncurrentTime: new Date().toString()\n};\n// Our root reducer starts with the initial state\n// and must return a representation of the next state\nexport const rootReducer = (state = initialState, action) => {\nreturn state;\n};\n\nIn the function, we're defining the first argument to start out as the initial\nstate (the first time it runs, the rootReducer is called with no arguments, so it\nwill always return the initialState on the first run).\nThat's the rootReducer for now. As it stands right now, the state always will\nbe the same value as the initialState. In our case, this means our data tree has\na single key of currentTime .","metadata":{"loc":{"lines":{"from":5537,"to":5554}}}}],["202",{"pageContent":"What is an action?\nThe second argument here is the action that gets dispatched from the store.\nWe'll come back to what that means exactly shortly. For now, let's look at the\naction.\nAt the very minimum, an action must include a type key. The type key can\nbe any value we want, but it must be present. For instance, in our application,\nwe'll occassionally dispatch an action that we want to tell the store to get the\nnew current time. We might call this action a string value of FETCH_NEW_TIME .\nThe action we might dispatch from our store to handle this update looks like:\n\n{\ntype: \"FETCH_NEW_TIME\"\n}\n\n185\n\n\fAs we'll by typing this string a lot and we want to avoid a possible mispelling\nsomewhere, it's common to create a types.js file that exports the action\ntypes as constants. Let's follow this convention and create a\nsrc/redux/types.js file:\n\nexport const FETCH_NEW_TIME = \"FETCH_NEW_TIME\";","metadata":{"loc":{"lines":{"from":5556,"to":5577}}}}],["203",{"pageContent":"export const FETCH_NEW_TIME = \"FETCH_NEW_TIME\";\n\nInstead of calling the action with the hard-coded string of\n'FETCH_NEW_TIME', we'll reference it from the types.js file:\n\nimport * as types from './types';\n{\ntype: types.FETCH_NEW_TIME,\n}\n\nWhen we want to send data along with our action, we can add any keys we\nwant to our action. We'll commonly see this called payload , but it can be\ncalled anything. It's a convention to call additional information the payload .\nOur FETCH_NEW_TIME action will send a payload with the new current time.\nSince we want to send a serializable value with our actions, we'll send the\nstring value of the new current time.\n\n{\ntype: types.FETCH_NEW_TIME,\npayload: new Date().toString() // Any serializable value\n}\n\nBack in our reducer, we can check for the action type and take the\nappropriate steps to create the next state. In our case, we'll just store the\npayload . If the type of the action is FETCH_NEW_TIME , we'll return the new","metadata":{"loc":{"lines":{"from":5577,"to":5601}}}}],["204",{"pageContent":"currentTime (from our action payload) and the rest of the state (using the\nES6 spread syntax):\n\n186\n\n\fexport const rootReducer = (state = initialState, action) => {\nswitch (action.type) {\ncase types.FETCH_NEW_TIME:\nreturn { ...state, currentTime: action.payload };\ndefault:\nreturn state;\n}\n};\n\nRemember, the reducers must return a state, so in the default case, make\nsure to return the current state at the very minimum.\n\nKeep it light\nSince the reducer functions run everytime an action is dispatched, we\nwant to make sure these functions are as simple and fast as possible. We\ndon't want them to cause any side-effects or have much delay at all.\nWe'll handle our side-effects outside of the reducer in the action creators.\n\nBefore we look at action creators (and why we call them action creators), let's\nhook up our store to our application.\nWe'll be using the react-redux package to connect our views to our redux\nstore. Let's make sure to install this package using npm :\n\nnpm install --save react-redux","metadata":{"loc":{"lines":{"from":5603,"to":5631}}}}],["205",{"pageContent":"npm install --save react-redux\n\nHooking up the store to the view\nThe react-redux package exports a component called Provider . The\nProvider component makes the store available to all of our container\n\ncomponents in our application without needing for us to need to pass it in\n\n187\n\n\fmanually every time.\nThe Provider component expects a store prop that it expects to be a valid\nredux store, so we'll need to complete a configureStore function before our\napp will run without error. For now, let's hook up the Provider component in\nour app. We'll do this by updating our wrapper Root component we\npreviously created to use the Provider component.\n\nimport { Provider } from \"react-redux\";\n// ...\nconst Root = props => {\n// ...\nreturn (\n<Provider store={store}>\n<App />\n</Provider>\n);\n};\n\nNotice we're sending in the store value to our Provider component... but\nwe haven't created the store yet! Let's fix that now.","metadata":{"loc":{"lines":{"from":5631,"to":5660}}}}],["206",{"pageContent":"Notice we're sending in the store value to our Provider component... but\nwe haven't created the store yet! Let's fix that now.\n\nConfiguring the store\nIn order to create a store, we'll use the new src/redux/configureStore.js to\nexport a function which will be responsible for creating the store.\nHow do we create a store?\nThe redux package exports a function called createStore which will create\nthe actual store for us, so let's open up the src/redux/configureStore.js file\nand export a function (we'll define shortly) called configureStore() and\nimport the createStore helper:\n\n188\n\n\fimport { createStore } from \"redux\";\n// ...\nexport const configureStore = () => {\n// ...\n};\n// ...\nexport default configureStore;\n\nWe don't actually return anything in our store quite yet, so let's actually\ncreate the redux store using the createStore function we imported from\nredux:","metadata":{"loc":{"lines":{"from":5660,"to":5684}}}}],["207",{"pageContent":"We don't actually return anything in our store quite yet, so let's actually\ncreate the redux store using the createStore function we imported from\nredux:\n\nimport { createStore } from \"redux\";\nexport const configureStore = () => {\nconst store = createStore();\nreturn store;\n};\nexport default configureStore;\n\nNow let's update our Root.js file with an instance of the store created by\ncalling the configureStore() function.\n\n// ...\nimport configureStore from \"../redux/configureStore\";\nconst Root = props => {\nconst store = configureStore();\nreturn (\n<Provider store={store}>\n<App />\n</Provider>\n);\n};\n\n189\n\n\fIf we load our page in the browser, we'll see we have one giant error and no\npage gets rendered.","metadata":{"loc":{"lines":{"from":5684,"to":5712}}}}],["208",{"pageContent":"189\n\n\fIf we load our page in the browser, we'll see we have one giant error and no\npage gets rendered.\n\nThe error redux is giving us is telling us that we don't have a reducer inside\nour store. Without a reducer, it won't know what to do with actions or how to\ncreate the state, etc. In order to move beyond this error, we'll need to\nreference our rootReducer we created.\nThe createStore function expects us to pass the rootReducer in as the first\nargument. It'll also expect the initial state to be passed in as the second\nargument. We'll import both of these values from the reducers.js file we\ncreated.\n\nimport { rootReducer, initialState } from \"./reducers\";\n// ...\nexport const configureStore = () => {\nconst store = createStore(\nrootReducer, // root reducer\ninitialState // our initialState\n);\nreturn store;\n};\n190","metadata":{"loc":{"lines":{"from":5712,"to":5735}}}}],["209",{"pageContent":"Connecting the view (cont'd)\nEverything in our app is set-up to use Redux without too much overhead.\nOne more convenience that redux offers is a way to bind pieces of the state\ntree to different components using the connect() function exported by the\nreact-redux package.\nThe connect() function returns a function that expects the 1st argument to\nbe that of a component. This is often called a higher-order component.\nThe connect() function expects us to pass in at least one argument to the\nfunction (but often we'll pass in two). The first argument it expects is a\nfunction that will get called with the state and expects an object in return\nthat connects data to the view. Let's see if we can demystify this behavior in\ncode.\nWe'll call this function the mapStateToProps function. Since it's responsibility\nis to map the state to an object which is merged with the component's\noriginal props .\nLet's create the Home view in src/views/Home.js and use this connect()","metadata":{"loc":{"lines":{"from":5737,"to":5752}}}}],["210",{"pageContent":"is to map the state to an object which is merged with the component's\noriginal props .\nLet's create the Home view in src/views/Home.js and use this connect()\nfunction to bind the value of currentTime in our state tree.","metadata":{"loc":{"lines":{"from":5752,"to":5755}}}}],["211",{"pageContent":"import { connect } from \"react-redux\";\n// ...\nconst mapStateToProps = state => {\nreturn {\ncurrentTime: state.currentTime\n};\n};\nexport default connect(mapStateToProps)(Home);\n\nThis connect() function automatically passes any of the keys in the\nfunction's first argument as props to the Home component.\n\n191\n\n\fIn our demo's case, the currentTime prop in the Home component will be\nmapped to the state tree key at currentTime . Let's update the Home\ncomponent to show the value in the currentTime :\n\nconst Home = props => {\nreturn (\n<div className=\"home\">\n<h1>Welcome home!</h1>\n<p>Current time: {props.currentTime}</p>\n</div>\n);\n};\n\nAlthough this demo isn't very interesting, it shows we have our Redux app set\nup with our data committed to the global state and our view components\nmapping the data.\n\nWelcome home!\nCurrent time: Thu Feb 27 2020 16:01:42 GMT­0600 (CST)","metadata":{"loc":{"lines":{"from":5757,"to":5789}}}}],["212",{"pageContent":"Welcome home!\nCurrent time: Thu Feb 27 2020 16:01:42 GMT­0600 (CST)\n\nTomorrow we're going to start triggering updates into our global state\nthrough action creators as well as work through combining multiple redux\nmodules together.\n\n192\n\n\fRedux actions\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-20/post.md)\n\nWith Redux in place, let's talk about how we actually modify the\nRedux state from within our applications.\nYesterday we went through the difficult part of integrating our React app\nwith Redux. From here on out, we'll be defining functionality with our Redux\nsetup.\nAs it stands now, we have our demo application showing the current time.\nBut there currently isn't any way to update to the new time. Let's modify this\nnow.\n\nTriggering updates\nRecall that the only way we can change data in Redux is through an action\ncreator. We created a redux store yesterday, but we haven't created a way for\nus to update the store.","metadata":{"loc":{"lines":{"from":5789,"to":5813}}}}],["213",{"pageContent":"Triggering updates\nRecall that the only way we can change data in Redux is through an action\ncreator. We created a redux store yesterday, but we haven't created a way for\nus to update the store.\n\nWelcome home!\nCurrent time: Thu Feb 27 2020 16:01:45 GMT­0600 (CST)\n\nWhat we want is the ability for our users to update the time by clicking on a\nbutton. In order to add this functionality, we'll have to take a few steps:\n\n193","metadata":{"loc":{"lines":{"from":5813,"to":5824}}}}],["214",{"pageContent":"What we want is the ability for our users to update the time by clicking on a\nbutton. In order to add this functionality, we'll have to take a few steps:\n\n193\n\n\f1. Create an actionCreator to dispatch the action on our store\n2. Call the actionCreator onClick of an element\n3. Handle the action in the reducer\nWe already implemented the third step, so we only have two things to do to\nget this functionality working as we expect.\nYesterday, we discussed what actions are, but not really why we are using\nthis thing called actionCreators or what they are.\nAs a refresher, an action is a simple object that must include a type value. We\ncreated a types.js file that holds on to action type constants, so we can use\nthese values as the type property.\n\nexport const FETCH_NEW_TIME = 'FETCH_NEW_TIME';\nexport const LOGIN = 'USER_LOGIN';\nexport const LOGOUT = 'USER_LOGOUT';","metadata":{"loc":{"lines":{"from":5824,"to":5842}}}}],["215",{"pageContent":"export const FETCH_NEW_TIME = 'FETCH_NEW_TIME';\nexport const LOGIN = 'USER_LOGIN';\nexport const LOGOUT = 'USER_LOGOUT';\n\nAs a quick review, our actions can be any object value that has the type key.\nWe can send data along with our action (conventionally, we'll pass extra data\nalong as the payload of an action).\n\n{\ntype: types.FETCH_NEW_TIME,\npayload: new Date().toString()\n}\n\nNow we need to dispatch this along our store . One way we could do that is\nby calling the store.dispatch() function.\n\nstore.dispatch({\ntype: types.FETCH_NEW_TIME,\npayload: new Date().toString()\n})\n\n194","metadata":{"loc":{"lines":{"from":5842,"to":5863}}}}],["216",{"pageContent":"Now we need to dispatch this along our store . One way we could do that is\nby calling the store.dispatch() function.\n\nstore.dispatch({\ntype: types.FETCH_NEW_TIME,\npayload: new Date().toString()\n})\n\n194\n\n\fHowever, this is pretty poor practice. Rather than dispatch the action\ndirectly, we'll use a function to return an action... the function will create the\naction (hence the name: actionCreator). This provides us with a better testing\nstory (easy to test), reusability, documentation, and encapsulation of logic.\nLet's create our first actionCreator in a file called redux/actionCreators.js .\nWe'll export a function who's entire responsibility is to return an appropriate\naction to dispatch on our store.\n\nimport * as types from './types';\nexport const fetchNewTime = () => ({\ntype: types.FETCH_NEW_TIME,\npayload: new Date().toString(),\n})","metadata":{"loc":{"lines":{"from":5863,"to":5885}}}}],["217",{"pageContent":"import * as types from './types';\nexport const fetchNewTime = () => ({\ntype: types.FETCH_NEW_TIME,\npayload: new Date().toString(),\n})\n\nNow if we call this function, nothing will happen except an action object is\nreturned. How do we get this action to dispatch on the store?\nRecall we used the connect() function export from react-redux yesterday?\nThe first argument is called mapStateToProps , which maps the state to a prop\nobject. The connect() function accepts a second argument which allows us\nto map functions to props as well. It gets called with the dispatch function,\nso here we can bind the function to call dispatch() on the store.\nLet's see this in action. In our src/views/Home/Home.js file, let's update our\ncall to connect by providing a second function to use the actionCreator we\njust created. We'll call this function mapDispatchToProps .\n\n195","metadata":{"loc":{"lines":{"from":5885,"to":5902}}}}],["218",{"pageContent":"195\n\n\fimport { fetchNewTime } from '../../../redux/actionCreators';\n// ...\nconst mapDispatchToProps = dispatch => ({\nupdateTime: () => dispatch(fetchNewTime())\n})\n// ...\nexport default connect(\nmapStateToProps,\nmapDispatchToProps,\n)(Home);\n\nNow the updateTime() function will be passed in as a prop and will call\ndispatch() when we fire the action. Let's update our <Home /> component\nso the user can press a button to update the time.\n\nconst Home = (props) => {\nreturn (\n<div className=\"home\">\n<h1>Welcome home!</h1>\n<p>Current time: {props.currentTime}</p>\n<button onClick={props.updateTime}>\nUpdate time\n</button>\n</div>\n);\n}\n\nWelcome home!\nCurrent time: Thu Feb 27 2020 16:01:45 GMT­0600 (CST)\nUpdate time\n\n196\n\n\fAlthough this example isn't that exciting, it does showcase the features of\nredux pretty well. Imagine if the button makes a fetch to get new tweets or\nwe have a socket driving the update to our redux store. This basic example\ndemonstrates the full functionality of redux.","metadata":{"loc":{"lines":{"from":5902,"to":5940}}}}],["219",{"pageContent":"Multi-reducers\nAs it stands now, we have a single reducer for our application. This works for\nnow as we only have a small amount of simple data and (presumably) only one\nperson working on this app. Just imagine the headache it would be to develop\nwith one gigantic switch statement for every single piece of data in our apps...\nAhhhhhhhhhhhhhh...\nRedux to the rescue! Redux has a way for us to split up our redux reducers\ninto multiple reducers, each responsible for only a leaf of the state tree.\nWe can use the combineReducers() export from redux to compose an object\nof reducer functions. For every action that gets triggered, each of these\nfunctions will be called with the corresponding action. Let's see this in action.\nLet's say that we (perhaps more realistically) want to keep track of the\ncurrent user. Let's create a currentUser redux module in... you guessed it:\nsrc/redux/currentUser.js :\n\ntouch src/redux/currentUser.js","metadata":{"loc":{"lines":{"from":5942,"to":5957}}}}],["220",{"pageContent":"touch src/redux/currentUser.js\n\nWe'll export the same four values we exported from the currentTime\nmodule... of course, this time it is specific to the currentUser. We've added a\nbasic structure here for handling a current user:\n\n197\n\n\fimport * as types from './types'\nexport const initialState = {\nuser: {},\nloggedIn: false\n}\nexport const reducer = (state = initialState, action) => {\nswitch (action.type) {\ncase types.LOGIN:\nreturn {\n...state, user: action.payload, loggedIn: true};\ncase types.LOGOUT:\nreturn {\n...state, user: {}, loggedIn: false};\ndefault:\nreturn state;\n}\n}\n\nLet's update our configureStore() function to take these branches into\naccount, using the combineReducers to separate out the two branches\n\n198","metadata":{"loc":{"lines":{"from":5957,"to":5986}}}}],["221",{"pageContent":"Let's update our configureStore() function to take these branches into\naccount, using the combineReducers to separate out the two branches\n\n198\n\n\fimport { createStore, combineReducers } from 'redux';\nimport { rootReducer, initialState } from './reducers'\nimport { reducer, initialState as userInitialState } from\n'./currentUser'\nexport const configureStore = () => {\nconst store = createStore(\ncombineReducers({\ntime: rootReducer,\nuser: reducer\n}), // root reducer\n{\ntime: initialState,\nuser: userInitialState\n}, // our initialState\n);\nreturn store;\n}\nexport default configureStore;\n\nLet's also update our Home component mapStateToProps function to read it's\nvalue from the time reducer\n\n// ...\nconst mapStateToProps = state => {\n// our redux store has `time` and `user` states\nreturn {\ncurrentTime: state.time.currentTime\n};\n};\n// ...\n\nNow we can create the login() and logout() action creators to send along\nthe action on our store.\n\n199","metadata":{"loc":{"lines":{"from":5986,"to":6025}}}}],["222",{"pageContent":"Now we can create the login() and logout() action creators to send along\nthe action on our store.\n\n199\n\n\fexport const login = (user) => ({\ntype: types.LOGIN,\npayload: user\n})\n// ...\nexport const logout = () => ({\ntype: types.LOGOUT,\n})\n\nNow we can use the actionCreators to call login and logout just like the\nupdateTime() action creator.\nPhew! This was another hefty day of Redux code. Today, we completed the\ncircle between data updating and storing data in the global Redux state. In\naddition, we learned how to extend Redux to use multiple reducers and\nactions as well as multiple connected components.\nHowever, we have yet to make an asynchronous call for off-site data.\nTomorrow we'll get into how to use middleware with Redux, which will give\nus the ability to handle fetching remote data from within our app and still use\nthe power of Redux to keep our data.\nGood job today and see you tomorrow!\n\n200","metadata":{"loc":{"lines":{"from":6025,"to":6051}}}}],["223",{"pageContent":"200\n\n\fRedux Middleware\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-21/post.md)\n\nToday, we're looking at the Redux method of managing complex\nstate changes in our code using Redux middleware.\nYesterday we connected the dots with Redux, from working through\nreducers, updating action creators, and connecting Redux to React\ncomponents. Redux middleware unlocks even more power which we'll touch\non today.\n\nRedux middleware\nMiddleware generally refers to software services that \"glue together\"\nseparate features in existing software. For Redux, middleware provides a\nthird-party extension point between dispatching an action and handing the\naction off to the reducer:\n[ Action ] <-> [ Middleware ] <-> [ Dispatcher ]\nExamples of middleware include logging, crash reporting, routing, handling\nasynchronous requests, etc.\nLet's take the case of handling asynchronous requests, like an HTTP call to a\nserver. Middleware is a great spot to do this.","metadata":{"loc":{"lines":{"from":6051,"to":6072}}}}],["224",{"pageContent":"Our API middleware\n201","metadata":{"loc":{"lines":{"from":6074,"to":6075}}}}],["225",{"pageContent":"We'll implement some middleware that will handle making asynchronous\nrequests on our behalf.\nMiddleware sits between the action and the reducer. It can listen for all\ndispatches and execute code with the details of the actions and the current\nstates. Middleware provides a powerful abstraction. Let's see exactly how we\ncan use it to manage our own.\nContinuing with our currentTime redux work from yesterday, let's build our\nmiddleware to fetch the current time from the server we used a few days ago\nto actually GET the time from the API service.\nBefore we get too much further, let's pull out the currentTime work from the\nrootReducer in the reducers.js file out to it's own file. We left the root\nreducer in a state where we kept the currentTime work in the root reducer.\nMore conventionally, we'll move these in their own files and use the\nrootReducer.js file (which we called reducers.js ) to hold just the main\ncombination reducer.","metadata":{"loc":{"lines":{"from":6077,"to":6091}}}}],["226",{"pageContent":"More conventionally, we'll move these in their own files and use the\nrootReducer.js file (which we called reducers.js ) to hold just the main\ncombination reducer.\nFirst, let's pull the work into it's own file in redux/currentTime.js . We'll\nexport two objects from here (and each reducer):\ninitialState - the initial state for this branch of the state tree\nreducer - this branch's reducer","metadata":{"loc":{"lines":{"from":6091,"to":6097}}}}],["227",{"pageContent":"202\n\n\fimport * as types from './types';\nexport const initialState = {\ncurrentTime: new Date().toString(),\n}\nexport const reducer = (state = initialState, action) => {\nswitch(action.type) {\ncase types.FETCH_NEW_TIME:\nreturn { ...state, currentTime: action.payload}\ndefault:\nreturn state;\n}\n}\nexport default reducer\n\nWith our currentTime out of the root reducer, we'll need to update the\nreducers.js file to accept the new file into the root reducer. Luckily, this is\npretty easy:\n\nimport { combineReducers } from 'redux';\nimport * as currentUser from './currentUser';\nimport * as currentTime from './currentTime';\nexport const rootReducer = combineReducers({\ncurrentTime: currentTime.reducer,\ncurrentUser: currentUser.reducer,\n})\nexport const initialState = {\ncurrentTime: currentTime.initialState,\ncurrentUser: currentUser.initialState,\n}\nexport default rootReducer\n\n203\n\n\fLastly, let's update the configureStore function to pull the rootReducer and\ninitial state from the file:","metadata":{"loc":{"lines":{"from":6099,"to":6135}}}}],["228",{"pageContent":"203\n\n\fLastly, let's update the configureStore function to pull the rootReducer and\ninitial state from the file:\n\nimport { rootReducer, initialState } from './reducers'\n// ...\nexport const configureStore = () => {\nconst store = createStore(\nrootReducer,\ninitialState,\n);\nreturn store;\n}\n\nBack to middleware\nMiddleware is basically a function that accepts the store , which is expected\nto return a function that accepts the next function, which is expected to\nreturn a function which accepts an action. Confusing? Let's look at what this\nmeans.\n\nThe simplest middleware possible\nLet's build the smallest middleware we possibly can to understand exactly\nwhat's happening and how to add it to our stack.\nLet's create our first middleware.\nNow the signature of middleware looks like this:\n\n// src/redux/loggingMiddleWare.js\nconst loggingMiddleware = (store) => (next) => (action) => {\n// Our middleware\n}\nexport default loggingMiddleware;\n\n204","metadata":{"loc":{"lines":{"from":6135,"to":6168}}}}],["229",{"pageContent":"// src/redux/loggingMiddleWare.js\nconst loggingMiddleware = (store) => (next) => (action) => {\n// Our middleware\n}\nexport default loggingMiddleware;\n\n204\n\n\fBefuddled about this middleware thing? Don't worry, we all are the first time\nwe see it. Let's peel it back a little bit and destructure what's going on. That\nloggingMiddleware description above could be rewritten like the following:\n\nconst loggingMiddleware = function(store) {\n// Called when calling applyMiddleware so\n// our middleware can have access to the store\nreturn function(next) {\n// next is the following action to be run\n// after this middleware\nreturn function(action) {\n// finally, this is where our logic lives for\n// our middleware.\n}\n}\n}\n\nWe don't need to worry about how this gets called, just that it does get called\nin that order. Let's enhance our loggingMiddleware so that we do actually log\nout the action that gets called:","metadata":{"loc":{"lines":{"from":6168,"to":6195}}}}],["230",{"pageContent":"We don't need to worry about how this gets called, just that it does get called\nin that order. Let's enhance our loggingMiddleware so that we do actually log\nout the action that gets called:\n\nconst loggingMiddleware = (store) => (next) => (action) => {\n// Our middleware\nconsole.log(`Redux Log:`, action)\n// call the next function\nnext(action);\n}\n\nOur middleware causes our store to, when every time an action is called,\nwe'll get a console.log with the details of the action.\nIn order to apply middleware to our stack, we'll use this aptly named\napplyMiddleware function as the third argument to the createStore()\n\nmethod.\n\n205\n\n\fimport { createStore, applyMiddleware } from 'redux';\n\nTo apply middleware, we can call this applyMiddleware() function in the\ncreateStore() method. In our src/redux/configureStore.js file, let's update\nthe store creation by adding a call to applyMiddleware() :","metadata":{"loc":{"lines":{"from":6195,"to":6219}}}}],["231",{"pageContent":"// ...\nimport loggingMiddleware from \"./loggingMiddleware\";\n// ...\nconst store = createStore(\nrootReducer,\ninitialState,\napplyMiddleware(\nloggingMiddleware,\n)\n);\n\nNow our middleware is in place. Open up the console in your browser to see\nall the actions that are being called for this demo. Try clicking on the Update\nbutton with the console open...\n\nWelcome home!\nCurrent time: Thu Feb 27 2020 16:01:49 GMT­0600 (CST)\nUpdate time\n\nAs we've seen, middleware gives us the ability to insert a function in our\nRedux action call chain. Inside that function, we have access to the action,\nstate, and we can dispatch other actions.\nWe want to write a middleware function that can handle API requests. We\ncan write a middleware function that listens only to actions corresponding to\nAPI requests. Our middleware can \"watch\" for actions that have a special\n\n206","metadata":{"loc":{"lines":{"from":6221,"to":6247}}}}],["232",{"pageContent":"206\n\n\fmarker. For instance, we can have a meta object on the action with a type of\n'api' . We can use this to ensure our middleware does not handle any\nactions that are not related to API requests:\n\n// src/redux/apiMiddleware.js\nconst apiMiddleware = store => next => action => {\nif (!action.meta || action.meta.type !== 'api') {\nreturn next(action);\n}\n// This is an api request\n}\nexport default apiMiddleware\n\nIf an action does have a meta object with a type of 'api' , we'll pick up the\nrequest in the apiMiddleware .\nLet's convert our fetchNewTime() actionCreator to include these properties\ninto an API request. Let's open up the actionCreators redux module we've\nbeen working with (in src/redux/actionCreators.js ) and find the\nfetchNewTime() function definition.\nLet's pass in the URL to our meta object for this request. We can even accept\nparameters from inside the call to the action creator:","metadata":{"loc":{"lines":{"from":6247,"to":6269}}}}],["233",{"pageContent":"const host = 'https://andthetimeis.com'\nexport const fetchNewTime = (timezone = 'pst', str='now') => ({\ntype: types.FETCH_NEW_TIME,\npayload: new Date().toString(),\nmeta: {\ntype: 'api',\nurl: host + '/' + timezone + '/' + str + '.json'\n}\n})\n\nWhen we press the button to update the time, our apiMiddleware will catch\nthis before it ends up in the reducer. For any calls that we catch in the\nmiddleware, we can pick apart the meta object and make requests using\n207\n\n\fthese options. Alternatively, we can just pass the entire sanitized meta object\nthrough the fetch() API as-is.\nThe steps our API middleware will have to take:\n1. Find the request URL and compose request options from meta\n2. Make the request\n3. Convert the request to a JavaScript object\n4. Respond back to Redux/user\nLet's take this step-by-step. First, to pull off the URL and create the\nfetchOptions to pass to fetch() . We'll put these steps in the comments in\n\nthe code below:\n\n208","metadata":{"loc":{"lines":{"from":6271,"to":6298}}}}],["234",{"pageContent":"the code below:\n\n208\n\n\fconst apiMiddleware = store => next => action => {\nif (!action.meta || action.meta.type !== 'api') {\nreturn next(action);\n}\n// This is an api request\n// Find the request URL and compose request options from meta\nconst {url} = action.meta;\nconst fetchOptions = Object.assign({}, action.meta);\n// Make the request\nfetch(url, fetchOptions)\n// convert the response to json\n.then(resp => resp.json())\n.then(json => {\n// respond back to the user\n// by dispatching the original action without\n// the meta object\nlet newAction = Object.assign({}, action, {\npayload: json.dateString\n});\ndelete newAction.meta;\nstore.dispatch(newAction);\n})\n}\nexport default apiMiddleware","metadata":{"loc":{"lines":{"from":6298,"to":6325}}}}],["235",{"pageContent":"We have several options for how we respond back to the user in the Redux\nchain. Personally, we prefer to respond with the same type the request was\nfired off without the meta tag and placing the response body as the payload\nof the new action.\nIn this way, we don't have to change our redux reducer to manage the\nresponse any differently than if we weren't making a request.\nWe're also not limited to a single response either. Let's say that our user\npassed in an onSuccess callback to be called when the request was complete.\nWe could call that onSuccess callback and then dispatch back up the chain:\n209","metadata":{"loc":{"lines":{"from":6327,"to":6336}}}}],["236",{"pageContent":"const apiMiddleware = store => next => action => {\nif (!action.meta || action.meta.type !== 'api') {\nreturn next(action);\n}\n// This is an api request\n// Find the request URL and compose request options from meta\nconst {url} = action.meta;\nconst fetchOptions = Object.assign({}, action.meta);\n// Make the request\nfetch(url, fetchOptions)\n// convert the response to json\n.then(resp => resp.json())\n.then(json => {\nif (typeof action.meta.onSuccess === 'function') {\naction.meta.onSuccess(json);\n}\nreturn json; // For the next promise in the chain\n})\n.then(json => {\n// respond back to the user\n// by dispatching the original action without\n// the meta object\nlet newAction = Object.assign({}, action, {\npayload: json.dateString\n});\ndelete newAction.meta;\nstore.dispatch(newAction);\n})\n}\n\nThe possibilities here are virtually endless. Let's add the apiMiddleware to\nour chain by updating it in the configureStore() function:\n\n210","metadata":{"loc":{"lines":{"from":6338,"to":6371}}}}],["237",{"pageContent":"The possibilities here are virtually endless. Let's add the apiMiddleware to\nour chain by updating it in the configureStore() function:\n\n210\n\n\fimport { createStore, applyMiddleware } from 'redux';\nimport { rootReducer, initialState } from './reducers'\nimport loggingMiddleware from './loggingMiddleware';\nimport apiMiddleware from './apiMiddleware';\nexport const configureStore = () => {\nconst store = createStore(\nrootReducer,\ninitialState,\napplyMiddleware(\napiMiddleware,\nloggingMiddleware,\n)\n);\nreturn store;\n}\nexport default configureStore;\n\nWelcome home!\nCurrent time: Thu Feb 27 2020 16:01:49 GMT­0600 (CST)\nUpdate time","metadata":{"loc":{"lines":{"from":6371,"to":6395}}}}],["238",{"pageContent":"Welcome home!\nCurrent time: Thu Feb 27 2020 16:01:49 GMT­0600 (CST)\nUpdate time\n\nNotice that we didn't have to change any of our view code to update how the\ndata was populated in the state tree. Pretty nifty, eh?\nThis middleware is pretty simplistic, but it's a good solid basis for building it\nout. Can you think of how you might implement a caching service, so that we\ndon't need to make a request for data we already have? How about one to\nkeep track of pending requests, so we can show a spinner for requests that\nare outstanding?\nAwesome! Now we really are Redux ninjas. We've conquered the Redux\nmountain and are ready to move on to the next step. Before we head there,\nhowever... pat yourself on the back. We've made it through week 3!\n211\n\n\f212\n\n\fIntroduction to Testing\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-22/post.md)","metadata":{"loc":{"lines":{"from":6395,"to":6414}}}}],["239",{"pageContent":"212\n\n\fIntroduction to Testing\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-22/post.md)\n\nTest suites are an upfront investment that pay dividends over\nthe lifetime of a system. Today we'll introduce the topic of\ntesting and discuss the different types of tests we can write.\nOkay, close your eyes for a second... wait, don't... it's hard to read with your\neyes closed, but imagine for a moment your application is getting close to\nyour first deployment.\nIt's getting close and it gets tiring to constantly run through the features in\nyour browser... and so inefficient.\nThere must be a better way...","metadata":{"loc":{"lines":{"from":6414,"to":6427}}}}],["240",{"pageContent":"Testing\nWhen we talk about testing, we're talking about the process of automating\nthe process of setting up and measuring our assumptions against assertions\nof functionality about our application.\nWhen we talk about front-end testing in React, we're referring to the process\nof making assertions about what our React app renders and how it responds\nto user interaction.\nWe'll discuss three different software testing paradigms: unit testing,\nfunctional testing, and integration testing.\n\nUnit tests\n\n213","metadata":{"loc":{"lines":{"from":6429,"to":6441}}}}],["241",{"pageContent":"Unit tests\n\n213\n\n\fUnit tests\nUnit testing refers to testing individual pieces (or units, hence the name) of\nour our code so we can be confident these specific pieces of code work as we\nexpect.\nFor example, we have a few reducers already in our application. These\nreducers comprise a single function that we can make assertions on under\ndifferent scenarios.\nIn React, Unit tests typically do not require a browser, can run incredibly\nquickly (no writing to the DOM required), and the assertions themselves are\nusually simple and terse.\nWe'll mostly concentrate on answering the question: with a given set of\ninputs (state and props), does the output match our expectations of what\nshould be in the virtual dom. In this case, we're testing the rendering output.","metadata":{"loc":{"lines":{"from":6441,"to":6457}}}}],["242",{"pageContent":"Functional testing\nWith functional testing, we're focused on testing the behavior of our\ncomponent. For instance, if we have a navigation bar with a user login/logout\nbutton, we can test our expectations that:\nGiven a logged in user, the navbar renders a button with the text Logout\nGiven no logged in user, the navbar renders a button with the text Login\nFunctional tests usually run in isolation (i.e. testing the component\nfunctionality without the rest of the application).\n\nIntegration testing\nFinally, the last type of testing we'll look at is integration testing. This type of\ntesting tests the entire service of our application and attempts to replicate\nthe experience an end-user would experience when using our application.\n\n214","metadata":{"loc":{"lines":{"from":6459,"to":6473}}}}],["243",{"pageContent":"214\n\n\fOn the order of speed and efficiency, integration testing is incredibly slow as\nit needs to run expectations against a live, running browser, where as unit\nand functional tests can run quite a bit faster (especially in React where the\nfunctional test is testing against the in-memory virtual dom rather than an\nactual browser render).\nWhen testing React components, we will test both our expectations of what\nis contained in the virtual dom as well as what is reflected in the actual dom.","metadata":{"loc":{"lines":{"from":6473,"to":6481}}}}],["244",{"pageContent":"The tools\nWe're going to use a testing library called called jasmine\n(http://jasmine.github.io) to provide a readable testing language and\nassertions.\nAs far as test running, there is a general debate around which test runner is\nthe easiest/most efficient to work with, largely between mocha\n(https://mochajs.org) and jest (https://facebook.github.io/jest).\nWe're going to use Jest in our adventure in testing with React as it's the\nofficial (take this with a grain of salt) test runner. Most of the code we'll be\nwriting will be in Jasmine, so feel free to use mocha, if it's your test library of\nchoice.\nFinally, we'll use a library we cannot live without called Enzyme\n(https://github.com/airbnb/enzyme) which puts the fun back in FUNctional\ntesting. Enzyme provides some pretty nice React testing utility functions that\nmake writing our assertions a cinch.\nTomorrow, we'll get our application set up with the testing tooling in place so\nthat we can start testing our application and be confident it works as we","metadata":{"loc":{"lines":{"from":6483,"to":6499}}}}],["245",{"pageContent":"make writing our assertions a cinch.\nTomorrow, we'll get our application set up with the testing tooling in place so\nthat we can start testing our application and be confident it works as we\nexpect. See you tomorrow!","metadata":{"loc":{"lines":{"from":6499,"to":6502}}}}],["246",{"pageContent":"215\n\n\f216\n\n\fImplementing Tests\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-23/post.md)\n\nYesterday we examined the different types of tests that we write\nin React. Today we'll see it in action. We'll install the\ndependencies required to set up tests as well as write our first\nassertions.\nLet's get our application set up to be tested. Since we're going to be using a\nfew different libraries, we'll need to install them before we can use them\n(obviously).\n\nDependencies\nWe're going to use the following npm libraries:\n\njest/jest-cli\nJest (https://facebook.github.io/jest/) is the official testing framework\nreleased by Facebook and is a fantastic testing framework for testing React\napplications. It is incredibly fast, provides sandboxed testing environments,\nsupport for snapshot testing, and more.\n\nbabel-jest/babel-preset-stage-0\n\n217","metadata":{"loc":{"lines":{"from":6504,"to":6530}}}}],["247",{"pageContent":"babel-jest/babel-preset-stage-0\n\n217\n\n\fWe'll write our tests using the stage 0 (or ES6-edge functionality), so we'll\nwant to make sure our test framework can read and process our ES6 in our\ntests and source files.\n\nsinon\nSinon is a test utility library which provides a way for us to write spies, stubs,\nand mocks. We'll discuss what these are when we need them, but we'll install\nthe library for now.\n\nreact-addons-test-utils/enzyme\nThe react-addons-test-utils package contains testing utilities provided by\nthe React team.\nEnzyme (http://airbnb.io/enzyme/), a JavaScript testing library\nbuilt/maintained by Airbnb is a bit easier to work with and provides really\nnice methods for traversing/manipulating React's virtual DOM output. While\nwe'll start with react-addons-test-utils , we'll transition to using Enzyme as\nwe prefer using it in our tests.","metadata":{"loc":{"lines":{"from":6530,"to":6550}}}}],["248",{"pageContent":"react-test-renderer\nThe react-test-renderer library allows us to use the snapshot feature from\nthe jest library. Snapshots are a way for Jest to serialize the rendered output\nfrom the virtual DOM into a file which we can automate comparisons from\none test to the next.\n\nredux-mock-store\nThe redux-mock-store (https://github.com/arnaudbenard/redux-mockstore) library allows us to easily make a redux store for testing. We'll use it to\ntest our action creators, middleware, and our reducers.\nTo install all of these libraries, we'll use the following npm command in the\nterminal while in the root directory of our projects:\n218\n\n\fyarn add --dev babel-jest babel-preset-stage-0 enzyme enzyme-adapterreact-16 jest-cli react-addons-test-utils react-test-renderer reduxmock-store sinon","metadata":{"loc":{"lines":{"from":6552,"to":6565}}}}],["249",{"pageContent":"yarn add --dev babel-jest babel-preset-stage-0 enzyme enzyme-adapterreact-16 jest-cli react-addons-test-utils react-test-renderer reduxmock-store sinon\n\nConfiguration\nWe'll also need to configure our setup. First, let's add an npm script that will\nallow us to run our tests using the npm test command. In our package.json\nfile in the root of our project, let's add the test script. Find the scripts key in\nthe package.json file and add the test command, like so:\n\n{\n// ...\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"eject\": \"react-scripts eject\",\n\"test\": \"react-scripts test --env=jsdom\"\n},\n}\n\nWriting tests\nLet's confirm that our test setup is working properly. Jest will automatically\nlook for test files in the entire tree in a directory called __tests__ (yes, with\nthe underscores). Let's create our first __tests__ directory in our\nsrc/components/Timeline directory and create our first test file:","metadata":{"loc":{"lines":{"from":6565,"to":6587}}}}],["250",{"pageContent":"mkdir src/components/Timeline/__tests__\ntouch src/components/Timeline/__tests__/Timeline-test.js\n\nThe Timeline-test.js file will include all the tests for our Timeline\ncomponent (as indicated by the filename). Let's create our first test for the\nTimeline component.\n219\n\n\fTimeline\n\n\n\nAn hour ago\n\nAte lunch\n10 am\n\nRead Day two article\n10 am\n\nLorem Ipsum is simply dummy text of the printing and\ntypesetting industry.\n2:21 pm\n\nLorem Ipsum has been the industry's standard dummy\ntext ever since the 1500s, when an unknown printer\ntook a galley of type and scrambled it to make a type\nspecimen book.\n\nWe'll write our tests using the Jasmine (http://jasmine.github.io) framework.\nJasmine provides a few methods we'll use quite a bit. Both of the following\nmethods accept two arguments, the first being a description string and the\nsecond a function to execute:\ndescribe()\nit()","metadata":{"loc":{"lines":{"from":6589,"to":6623}}}}],["251",{"pageContent":"The describe() function provides a way for us to group our tests together in\nlogical bundles. Since we're writing a bunch of tests for our Timeline , we'll\nuse the describe() function in our test to indicate we're testing the\nTimeline.\n\n220\n\n\fIn the src/components/Timeline/__tests__/Timeline-test.js file, let's add\nthe describe block:\n\ndescribe(\"Timeline\", () => {});\n\nWe can add our first test using the it() function. The it() function is\nwhere we will set our expectations. Let's set up our tests with our first\nexpectations, one passing and one failing so we can see the difference in\noutput.\nIn the same file, let's add two tests:\n\ndescribe(\"Timeline\", () => {\nit(\"passing test\", () => {\nexpect(true).toBeTruthy();\n});\nit(\"failing test\", () => {\nexpect(false).toBeTruthy();\n});\n});\n\nWe'll look at the possible expectations we can set in a moment. First, let's run\nour tests.","metadata":{"loc":{"lines":{"from":6625,"to":6653}}}}],["252",{"pageContent":"We'll look at the possible expectations we can set in a moment. First, let's run\nour tests.\n\nExecuting tests\nThe create-react-app package sets up a quality testing environment using\nJest automatically for us. We can execute our tests by using the yarn test or\nnpm test script.\n\nIn the terminal, let's execute our tests:\n\nyarn test\n\n221\n\n\fFrom this output, we can see the two tests with one passing test (with a\ngreen checkmark) and one failing test (with the red x and a description of the\nfailure).\nLet's update the second test to make it pass by changing the expectation to\ntoBeFalsy() :\n\ndescribe(\"Timeline\", () => {\nit(\"passing test\", () => {\nexpect(true).toBeTruthy();\n});\nit(\"failing test\", () => {\nexpect(false).toBeFalsy();\n});\n});\n\nRe-running the test, we can see we have two passing tests\n\nyarn test\n\n222","metadata":{"loc":{"lines":{"from":6653,"to":6686}}}}],["253",{"pageContent":"Re-running the test, we can see we have two passing tests\n\nyarn test\n\n222\n\n\fExpectations\nJest provides a few global commands in our tests by default (i.e. things you\ndon't need to require). One of those is the expect() command. The expect()\ncommand has a few expectations which we can call on it, including the two\nwe've used already:\ntoBeTruthy()\ntoBeFalsy()\ntoBe()\ntoEqual()\ntoBeDefined()\ntoBeCalled()\n\netc.\nThe entire suite of expectations is available on the jest documentation page\nat: https://facebook.github.io/jest/docs/api.html#writing-assertions-withexpect (https://facebook.github.io/jest/docs/api.html#writing-assertionswith-expect).\n\n223","metadata":{"loc":{"lines":{"from":6686,"to":6708}}}}],["254",{"pageContent":"223\n\n\fThe expect() function takes a single argument: the value or function that\nreturns a value to be tested. For instance, our two tests we've already writen\npass the boolean values of true and false .\nNow that we've written our first tests and confirmed our setup, we'll actually\nget down to testing our Timeline component tomorrow. Great job today and\nsee you tomorrow!\n\n224\n\n\fTesting the App\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-24/post.md)","metadata":{"loc":{"lines":{"from":6708,"to":6720}}}}],["255",{"pageContent":"224\n\n\fTesting the App\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-24/post.md)\n\nLet's start by looking at one feature of our application and\nthinking about where the edge cases are and what we assume\nwill happen with the component.\nLet's start with the Timeline component as it's the most complex in our\ncurrent app.\nThe Timeline component dispays a list of statuses with a header with a\ndynamic title. We'll want to test any dynamic logic we have in our\ncomponents. The simplest bit of logic we have to start out with our tests are\naround the dynamic title presented on the timeline.\n\nTimeline\n\n\n\nAn hour ago\n\nAte lunch\n10 am\n\nRead Day two article\n10 am\n\nLorem Ipsum is simply dummy text of the printing and\ntypesetting industry.\n2:21 pm\n225\n\n\fLorem Ipsum has been the industry's standard dummy\ntext ever since the 1500s, when an unknown printer\ntook a galley of type and scrambled it to make a type\nspecimen book.","metadata":{"loc":{"lines":{"from":6720,"to":6755}}}}],["256",{"pageContent":"Lorem Ipsum has been the industry's standard dummy\ntext ever since the 1500s, when an unknown printer\ntook a galley of type and scrambled it to make a type\nspecimen book.\n\nWe like to start out testing by listing our assumptions about a component\nand under what circumstances these assumptions are true. For instance, a\nlist of assumptions we can make about our Timeline component might\ninclude the following:\nUnder all circumstances, the Timeline will be contained within a <div\n/> with the class of .notificationsFrame\nUnder all circumstances, we can assume there will be a title\nUnder all circumstances, we assume the search button will start out as\nhidden\nThere is a list of at least four status updates\nThese assumptions will translate into our tests.\n\nTesting\nLet's open the file src/components/Timeline/__tests__/Timeline-test.js . We\nleft off with some dummy tests in this file, so let's clear those off and start\nwith a fresh describe block:\n\ndescribe(\"Timeline\", () => {\n// Tests go here\n});\n\n226","metadata":{"loc":{"lines":{"from":6755,"to":6781}}}}],["257",{"pageContent":"describe(\"Timeline\", () => {\n// Tests go here\n});\n\n226\n\n\fFor every test that we write against React, we'll want to import react into our\ntest file. We'll also want to bring in the react test utilities:\n\nimport React from \"react\";\nimport TestUtils from \"react-dom/test-utils\";\ndescribe(\"Timeline\", () => {\n// Tests go here\n});\n\nSince we're testing the Timeline component here, we'll also want to bring\nthat into our workspace:\n\nimport React from \"react\";\nimport TestUtils from \"react-dom/test-utils\";\nimport Timeline from \"../Timeline\";\ndescribe(\"Timeline\", () => {\n// Tests go here\n});\n\nLet's write our first test. Our first assumption is pretty simple to test. We're\ntesting to make sure the element is wrapped in a .notificationsFrame class.\nWith every test we'll write, we'll need to render our application into the\nworking test document. The react-dom/test-utils library provides a\nfunction to do just this called renderIntoDocument() :\n\n227","metadata":{"loc":{"lines":{"from":6781,"to":6812}}}}],["258",{"pageContent":"227\n\n\fimport React from \"react\";\nimport TestUtils from \"react-dom/test-utils\";\nimport Timeline from \"../Timeline\";\ndescribe(\"Timeline\", () => {\nit(\"wraps content in a div with .notificationsFrame class\", () => {\nconst wrapper = TestUtils.renderIntoDocument(<Timeline />);\n});\n});\n\nIf we run this test (even though we're not setting any expectations yet), we'll\nsee that we have a problem with the testing code. React thinks we're trying to\nrender an undefined component:\nLet's find the element we expect to be in the DOM using another TestUtils\nfunction called findRenderedDOMComponentWithClass() .\nThe findRenderedDOMComponentWithClass() function accepts two arguments.\nThe first is the render tree (our wrapper object) and the second is the CSS\nclass name we want it to look for:","metadata":{"loc":{"lines":{"from":6812,"to":6830}}}}],["259",{"pageContent":"import React from \"react\";\nimport TestUtils from \"react-dom/test-utils\";\nimport Timeline from \"../Timeline\";\ndescribe(\"Timeline\", () => {\nit(\"wraps content in a div with .notificationsFrame class\", () => {\nconst wrapper = TestUtils.renderIntoDocument(<Timeline />);\nconst node = TestUtils.findRenderedDOMComponentWithClass(\nwrapper,\n\"notificationsFrame\"\n);\n});\n});\n\n228\n\n\fWith that, our tests will pass (believe it or not). The TestUtils sets up an\nexpectation that it can find the component with the .notificationsFrame\nclass. If it doesn't find one, it will throw an error and our tests will fail.\nAs a reminder, we can run our tests using either the npm test command or\nthe yarn test command. We'll use the yarn test command for now since\nwe're testing one component:\n\nyarn test\n\n229","metadata":{"loc":{"lines":{"from":6832,"to":6856}}}}],["260",{"pageContent":"yarn test\n\n229\n\n\fWith our one passing test, we've confirmed our test setup is working.\nUnfortunately, the interface for TestUtils is a little complex and low-level.\nThe enzyme library wraps TestUtils , providing an easier and higher-level\ninterface for asserting against a React component under test. We'll discuss\nenzyme in detail tomorrow.\nGreat job today and see you tomorrow!\n\n230\n\n\fBetter Testing with Enzyme\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-25/post.md)","metadata":{"loc":{"lines":{"from":6856,"to":6870}}}}],["261",{"pageContent":"230\n\n\fBetter Testing with Enzyme\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-25/post.md)\n\nToday, we'll look at an open-source library maintained by Airbnb\ncalled Enzyme that makes testing fun and easy.\nYesterday we used the react-dom/test-utils library to write our first test\nagainst the Timeline component. However, this library is fairly low-level and\ncan be a bit cumbersome to use. Enzyme (http://airbnb.io/enzyme/) is a\ntesting utility library released and maintained by the AirBnb (http://airbnb.io)\nteam and it offers a nicer, higher-level API for dealing with React components\nunder test.\nWe're testing against our <Timeline /> component:\n\n\n\nTimeline\n\nNate Tue Apr 04 2017 17:00:51 GMT-0700 (MST)\nAte lunch\n\nAri\n\nTue Apr 04 2017 17:00:51 GMT-0700 (MST)\n\nPlayed tennis\n\nNate Tue Apr 04 2017 17:00:51 GMT-0700 (MST)\nWalked the dog\n\nAri\n\nTue Apr 04 2017 17:00:51 GMT-0700 (MST)\n\nCalled mom\n\n1\n\n\n\n1\n\n\n\n0\n\n\n\n2\n\n\n231","metadata":{"loc":{"lines":{"from":6870,"to":6922}}}}],["262",{"pageContent":"Ari\n\nTue Apr 04 2017 17:00:51 GMT-0700 (MST)\n\nPlayed tennis\n\nNate Tue Apr 04 2017 17:00:51 GMT-0700 (MST)\nWalked the dog\n\nAri\n\nTue Apr 04 2017 17:00:51 GMT-0700 (MST)\n\nCalled mom\n\n1\n\n\n\n1\n\n\n\n0\n\n\n\n2\n\n\n231\n\n\fUsing Enzyme\nWe'll use Enzyme to make these tests easier to write and more readable.\nYesterday, we wrote our first test as the following:\n\nimport React from \"react\";\nimport TestUtils from \"react-dom/test-utils\";\nimport Timeline from \"../Timeline\";\ndescribe(\"Timeline\", () => {\nit(\"wraps content in a div with .notificationsFrame class\", () => {\nconst wrapper = TestUtils.renderIntoDocument(<Timeline />);\nTestUtils.findRenderedDOMComponentWithClass(wrapper,\n\"notificationsFrame\");\n});\n});","metadata":{"loc":{"lines":{"from":6922,"to":6967}}}}],["263",{"pageContent":"Although this works, it's not quite the easiest test in the world to read. Let's\nsee what this test looks like when we rewrite it with Enzyme.\nRather than testing the complete component tree with Enzyme, we can test\njust the output of the component. Any of the component's children will not\nbe rendered. This is called shallow rendering.\nEnzyme makes shallow rendering super easy. We'll use the shallow function\nexported by Enzyme to mount our component.\n\n232\n\n\fLet's first configure enzyme use the adapter that makes it compatible with\nReact version 16. Create src/setupTests.js and add the following:\n\nimport { configure } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nconfigure({ adapter: new Adapter() });\n\nLet's update the src/components/Timeline/__tests__/Timeline-test.js file to\ninclude the shallow function from enzyme :","metadata":{"loc":{"lines":{"from":6969,"to":6987}}}}],["264",{"pageContent":"Let's update the src/components/Timeline/__tests__/Timeline-test.js file to\ninclude the shallow function from enzyme :\n\nimport React from \"react\";\nimport { shallow } from \"enzyme\";\ndescribe(\"Timeline\", () => {\nit(\"wraps content in a div with .notificationsFrame class\", () => {\n// our tests\n});\n});\n\nShallow rendering is supported by react-dom/test-utils as\nwell. In fact, Enzyme just wraps this functionality. While we\ndidn't use shallow rendering yesterday, if we were to use it\nwould look like this:\nconst renderer = ReactTestUtils.createRenderer();\nrenderer.render(<Timeline />);\nconst result = renderer.getRenderOutput();\n\nNow to render our component, we can use the shallow method and store\nthe result in a variable. Then, we'll query the rendered component for\ndifferent React elements (HTML or child components) that are rendered\ninside its virtual dom.\n233\n\n\fThe entire assertion comprises two lines:","metadata":{"loc":{"lines":{"from":6987,"to":7012}}}}],["265",{"pageContent":"The entire assertion comprises two lines:\n\nimport React from \"react\";\nimport { shallow, mount } from \"enzyme\";\nimport Timeline from \"../Timeline\";\ndescribe(\"Timeline\", () => {\nlet wrapper;\nit(\"wraps content in a div with .notificationsFrame class\", () => {\nwrapper = shallow(<Timeline />);\nexpect(wrapper.find(\".notificationsFrame\").length).toEqual(1);\n});\n});\n\nWe can run our tests in the same manner as we did before using the yarn\ntest command (or the npm test command):\n\nyarn test\n\nOur test passes and is more readable and maintainable.\n234\n\n\fLet's continue writing assertions, pulling from the list of assumptions that we\nmade at the beginning of yesterday. We'll structure the rest of our test suite\nfirst by writing out our describe and it blocks. We'll fill out the specs with\nassertions after:","metadata":{"loc":{"lines":{"from":7012,"to":7036}}}}],["266",{"pageContent":"import React from \"react\";\nimport { shallow } from \"enzyme\";\nimport Timeline from \"../Timeline\";\ndescribe(\"Timeline\", () => {\nlet wrapper;\nit(\"wraps content in a div with .notificationsFrame class\", () => {\nwrapper = shallow(<Timeline />);\nexpect(wrapper.find(\".notificationsFrame\").length).toEqual(1);\n});\nit(\"has a title of Timeline\");\ndescribe(\"search button\", () => {\nit(\"starts out hidden\");\nit(\"becomes visible after being clicked on\");\n});\ndescribe(\"status updates\", () => {\nit(\"has 4 status updates at minimum\");\n});\n});\n\nIf we were following Test Driven Development (or TDD for\nshort), we would write these assumptions first and then build\nthe component to pass these tests.\n\nLet's fill in these tests so that they pass against our existing Timeline\ncomponent.\n235","metadata":{"loc":{"lines":{"from":7038,"to":7063}}}}],["267",{"pageContent":"Let's fill in these tests so that they pass against our existing Timeline\ncomponent.\n235\n\n\fOur title test is relatively simple. We'll look for the title element and confirm\nthe title is Timeline .\nWe expect the title to be available under a class of .title . So, to use the\n.title class in a spec, we can just grab the component using the find\nfunction exposed by Enzyme.\nSince our Header component is a child component of our Timeline\ncomponent, we can't use the shallow() method. Instead we have to use the\nmount() method provided by Enzyme.\n\nShallow? Mount?\nThe shallow() rendering function only renders the component we're\ntesting specifically and it won't render child elements. Instead we'll have\nto mount() the component as the child Header won't be available in the\njsdom otherwise.\nWe'll look at more Enzyme functions at the end of this article.\n\nLet's fill out the title spec now:\n\n236","metadata":{"loc":{"lines":{"from":7063,"to":7085}}}}],["268",{"pageContent":"Let's fill out the title spec now:\n\n236\n\n\fimport React from \"react\";\nimport { shallow, mount } from \"enzyme\";\nimport Timeline from \"../Timeline\";\ndescribe(\"Timeline\", () => {\nlet wrapper;\nit(\"wraps content in a div with .notificationsFrame class\", () => {\nwrapper = shallow(<Timeline />);\nexpect(wrapper.find(\".notificationsFrame\").length).toEqual(1);\n});\nit(\"has a title of Timeline\", () => {\nwrapper = mount(<Timeline />); // notice the `mount`\nexpect(wrapper.find(\".title\").text()).toBe(\"Timeline\");\n});\n});\n\nRunning our tests, we'll see these two expectations pass:\n\nNext, let's update our search button tests. We have two tests here, where one\nrequires us to test an interaction. Enzyme provides a very clean interface for\nhandling interactions. Let's see how we can write a test against the search\n\n237","metadata":{"loc":{"lines":{"from":7085,"to":7110}}}}],["269",{"pageContent":"237\n\n\ficon.\nAgain, since we're testing against a child element in our Timeline, we'll have\nto mount() the element. Since we're going to write two tests in a nested\ndescribe() block, we can write a before helper to create the mount() anew\n\nfor each test so they are pure.\nIn addition, we're going to use the input.searchInput element for both tests,\nso let's write the .find() for that element in the before helper too.\n\ndescribe(\"Timeline\", () => {\nlet wrapper;\n// ...\ndescribe(\"search button\", () => {\nbeforeEach(() => (wrapper = mount(<Timeline />)));\n// ...\n});\n});\n\nTo test if the search input is hidden, we'll just have to know if the active\nclass is applied or not. Enzyme provides a way for us to detect if a component\nhas a class or not using the hasClass() method. Let's fill out the first test to\nexpect the search input doens't have the active class:\n\n238","metadata":{"loc":{"lines":{"from":7110,"to":7135}}}}],["270",{"pageContent":"238\n\n\fdescribe(\"Timeline\", () => {\nlet wrapper;\n// ...\ndescribe(\"search button\", () => {\nbeforeEach(() => (wrapper = mount(<Timeline />)));\nit(\"starts out hidden\", () => {\nexpect(wrapper.find(\"input.searchInput\").hasClass(\"active\")).toBeFalsy\n();\n});\nit(\"becomes visible after being clicked on\");\n// ...\n});\n});\n\nThe tricky part about the second test is that we need to click on the icon\nelement. Before we look at how to do that, let's find it first. We can target it\nby it's .searchIcon class on the wrapper:\n\nit(\"becomes visible after being clicked on\", () => {\nconst icon = wrapper.find(\".searchIcon\");\n});","metadata":{"loc":{"lines":{"from":7135,"to":7157}}}}],["271",{"pageContent":"it(\"becomes visible after being clicked on\", () => {\nconst icon = wrapper.find(\".searchIcon\");\n});\n\nNow that we have the icon we want to simulate a click on the element. Recall\nthat the onClick() method is really just a facade for browser events. That is,\na click on an element is just an event getting bubbled through the\ncomponent. Rather than controlling a mouse or calling click on the\nelement, we'll simulate an event occurring on it. For us, this will be the click\nevent.\nWe'll use the simulate() method on the icon to create this event:\n\nit(\"becomes visible after being clicked on\", () => {\nconst icon = wrapper.find(\".searchIcon\");\nicon.simulate(\"click\");\n});\n239\n\n\fNow we can set an expectation that the search component has the active\nclass.\n\nit(\"becomes visible after being clicked on\", () => {\nconst icon = wrapper.find(\".searchIcon\");\nicon.simulate(\"click\");\nexpect(wrapper.find(\"input.searchInput\").hasClass(\"active\")).toBeTruth\ny();\n});","metadata":{"loc":{"lines":{"from":7157,"to":7183}}}}],["272",{"pageContent":"it(\"becomes visible after being clicked on\", () => {\nconst icon = wrapper.find(\".searchIcon\");\nicon.simulate(\"click\");\nexpect(wrapper.find(\"input.searchInput\").hasClass(\"active\")).toBeTruth\ny();\n});\n\nOur last expectation for the Timeline component is that we have at least\nfour status updates. As we are laying these elements on the Timeline\ncomponent, we can shallow render the component. In addition, since each\nof the elements are of a custom component, we can search for the list of\nspecific components of type 'ActivityItem'.\n\ndescribe(\"status updates\", () => {\nit(\"has 4 status updates at minimum\", () => {\nwrapper = shallow(<Timeline />);\n// ...\n});\n});\n\nNow we can test for the length of a list of ActivityItem components. We'll\nset our expectation that the list if at least of length 4.\n\ndescribe(\"status updates\", () => {\nit(\"has 4 status updates at minimum\", () => {\nwrapper = shallow(<Timeline />);\nexpect(wrapper.find(\"ActivityItem\").length).toBeGreaterThan(3);\n});\n});","metadata":{"loc":{"lines":{"from":7183,"to":7211}}}}],["273",{"pageContent":"describe(\"status updates\", () => {\nit(\"has 4 status updates at minimum\", () => {\nwrapper = shallow(<Timeline />);\nexpect(wrapper.find(\"ActivityItem\").length).toBeGreaterThan(3);\n});\n});\n\nThe entire test suite that we have now is the following:\n\n240","metadata":{"loc":{"lines":{"from":7211,"to":7220}}}}],["274",{"pageContent":"import React from \"react\";\nimport { shallow, mount } from \"enzyme\";\nimport Timeline from \"../Timeline\";\ndescribe(\"Timeline\", () => {\nlet wrapper;\nit(\"wraps content in a div with .notificationsFrame class\", () => {\nwrapper = shallow(<Timeline />);\nexpect(wrapper.find(\".notificationsFrame\").length).toEqual(1);\n});\nit(\"has a title of Timeline\", () => {\nwrapper = mount(<Timeline />);\nexpect(wrapper.find(\".title\").text()).toBe(\"Timeline\");\n});\ndescribe(\"search button\", () => {\nbeforeEach(() => (wrapper = mount(<Timeline />)));\nit(\"starts out hidden\", () => {\nexpect(wrapper.find(\"input.searchInput\").hasClass(\"active\")).toBeFalsy\n();\n});\nit(\"becomes visible after being clicked on\", () => {\nconst icon = wrapper.find(\".searchIcon\");\nicon.simulate(\"click\");\nexpect(wrapper.find(\"input.searchInput\").hasClass(\"active\")).toBeTruth\ny();\n});\n});\ndescribe(\"status updates\", () => {\nit(\"has 4 status updates at minimum\", () => {\nwrapper = shallow(<Timeline />);\nexpect(wrapper.find(\"ActivityItem\").length).toBeGreaterThan(3);\n});\n});","metadata":{"loc":{"lines":{"from":7222,"to":7253}}}}],["275",{"pageContent":"y();\n});\n});\ndescribe(\"status updates\", () => {\nit(\"has 4 status updates at minimum\", () => {\nwrapper = shallow(<Timeline />);\nexpect(wrapper.find(\"ActivityItem\").length).toBeGreaterThan(3);\n});\n});\n});\n241","metadata":{"loc":{"lines":{"from":7253,"to":7263}}}}],["276",{"pageContent":"What's the deal with find() ?\nBefore we close out for today, we should look at the interface of an Enzyme\nshallow-rendered component (in our tests, the wrapper object). The Enzyme\ndocumentation (http://airbnb.io/enzyme/docs/api/shallow.html) is\nfantastic, so we'll keep this short.\nBasically, when we use the find() function, we'll pass it a selector and it will\nreturn a ShallowWrapper instance that wraps the found nodes. The find()\nfunction can take a string, function, or an object.\nWhen we pass strings into the find() function, we can pass CSS selectors or\nthe displayName of a component. For instance:\n\nwrapper.find(\"div.link\");\nwrapper.find(\"Link\");\n\nWe can also pass it the component constructor, for instance:\n\nimport { Link } from \"react-router\";\n// ...\nwrapper.find(Link);\n\nFinally, we can also pass it an object property selector object, which selects\nelements by their key and values. For instance:\n\nwrapper.find({ to: \"/login\" });","metadata":{"loc":{"lines":{"from":7265,"to":7288}}}}],["277",{"pageContent":"Finally, we can also pass it an object property selector object, which selects\nelements by their key and values. For instance:\n\nwrapper.find({ to: \"/login\" });\n\nThe return value is a ShallowWrapper , which is a type of Wrapper (we can\nhave rendered wrappers and shallow wrappers). These Wrapper instances\nhave a bunch of functions we can use to target different child components,\nways to look into the props and the state , as well as other attributes of a\nrendered component, such as html() and text() . What's more, we can\nchain these calls together.\n242\n\n\fTake the case of the <Link /> component. If we wanted to find the HTML of\nthe link class based on all the links available, we can write a test like this:\n\n// ...\nit(\"displays a link tag with the Login text\", () => {\nlink = wrapper.find(\"Link\").find({ to: \"/login\" });\nexpect(link.html()).toBe('<a class=\"link\">Login</a>');\n});","metadata":{"loc":{"lines":{"from":7288,"to":7308}}}}],["278",{"pageContent":"// ...\nit(\"displays a link tag with the Login text\", () => {\nlink = wrapper.find(\"Link\").find({ to: \"/login\" });\nexpect(link.html()).toBe('<a class=\"link\">Login</a>');\n});\n\nPhew! That's a lot of new information today, but look how quickly we wrote\nour follow-up tests with Enzyme. It's much quicker to read and makes it\neasier to discern what's actually happening.\nTomorrow we'll continue with our testing journey and walk through\nintegration testing our application.\n\n243\n\n\fIntegration Testing\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-26/post.md)","metadata":{"loc":{"lines":{"from":7308,"to":7323}}}}],["279",{"pageContent":"243\n\n\fIntegration Testing\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-26/post.md)\n\nToday we'll write tests to simulate how users interact with our\napplication and will test the entire flow of our app in a live\nbrowser.\nWe've reached the final part of our introduction to testing. We're going to\nwrap up our testing section with integration testing. As a reminder of what\nIntegration testing is, it's the process of automating the experience that our\nactual users experience as they use our application.\n\nLogo (/)\n\nLogin please (/login)\n\nAbout (/about)\n\nYou need to know the secret\n\nIntegration testing\nAs we're integration testing, we'll need to have our app actually running as\nwe're going to have a browser launch and execute our application. We'll be\nusing an automation server called selenium (http://www.seleniumhq.org), so\n\n244","metadata":{"loc":{"lines":{"from":7323,"to":7349}}}}],["280",{"pageContent":"244\n\n\fwe'll need to download it as well as a really nifty node automated testing\nframework called Nightwatch (http://nightwatchjs.org).\n\nInstall\nThe easiest way to install selenium (http://docs.seleniumhq.org/download/)\nis to download it through the the selenium website at:\nhttp://docs.seleniumhq.org/download/\n(http://docs.seleniumhq.org/download/).\n\nIf you're on a mac, you can use Homebrew (http://brew.sh)\nwith the brew command:\nbrew install selenium-server-standalone\n\nWe'll also need to install the nightwatch command, which we can do with the\nnpm package manager. Let's install nightwatch globally using the --global\nflag:\n\nnpm install --global nightwatch\n\nThis command gives us the nightwatch command available anywhere in our\nterminal. We'll need to add a configuration file in the root directory called\nnighwatch.json (or nighwatch.conf.js ). We'll use the default configuration\nfile at nighwatch.json\nLet's create the file in our root directory:\n\ntouch nightwatch.json","metadata":{"loc":{"lines":{"from":7349,"to":7376}}}}],["281",{"pageContent":"touch nightwatch.json\n\nNow add the following content in the new nightwatch.json :\n245\n\n\f{\n\"src_folders\" : [\"tests\"],\n\"output_folder\" : \"reports\",\n\"selenium\" : {\n\"start_process\" : false,\n\"server_path\" : \"\",\n\"log_path\" : \"\",\n\"host\" : \"127.0.0.1\",\n\"port\" : 4444,\n\"cli_args\" : {\n\"webdriver.chrome.driver\" : \"\",\n\"webdriver.ie.driver\" : \"\"\n}\n},\n\"test_settings\" : {\n\"default\" : {\n\"launch_url\" : \"http://localhost:3000\",\n\"selenium_port\" : 4444,\n\"selenium_host\" : \"localhost\",\n\"silent\": true,\n\"screenshots\" : {\n\"enabled\" : false,\n\"path\" : \"\"\n},\n\"desiredCapabilities\": {\n\"browserName\": \"chrome\",\n\"javascriptEnabled\": true,\n\"acceptSslCerts\": true\n}\n},\n\"chrome\" : {\n\"desiredCapabilities\": {\n\"browserName\": \"chrome\",\n\"javascriptEnabled\": true,\n\"acceptSslCerts\": true\n}\n}\n}\n}\n246","metadata":{"loc":{"lines":{"from":7376,"to":7420}}}}],["282",{"pageContent":"Nightwatch gives us a lot of configuration options available, so we won't\ncover all the possible ways to configure it. For our purposes, we'll just use the\nbase configuration above as it's more than enough for getting integration\ntesting going.\n\nWriting tests\nWe'll write our nightwatch tests in a tests/ directory. Let's start by writing a\ntest for handling the auth workflow. Let's write our test in a tests/ directory\n(which matches the src_folders ) that we'll call tests/auth-flow.js .\n\nmkdir tests\ntouch tests/auth-flow.js\n\nThe nightwatch tests can be set as an object of exports, where the key is the\ndescription of the test and the value is a function with a reference to the\nclient browser. For instance, we'll set up four tests for our tests/authflow.js test.\n\nUpdating our tests/auth-flow.js file with these four test functions look like\nthe following:\n\nmodule.exports = {\n\"get to login page\": browser => {},\n\"logging in\": browser => {},\n\"logging out\": browser => {},\nclose: browser => {}\n};","metadata":{"loc":{"lines":{"from":7422,"to":7447}}}}],["283",{"pageContent":"module.exports = {\n\"get to login page\": browser => {},\n\"logging in\": browser => {},\n\"logging out\": browser => {},\nclose: browser => {}\n};\n\nEach of the functions in our object exports will receive a browser instance\nwhich serves as the interface between our test and the selenium webdriver.\nWe have all sorts of available options we can run on this browser variable.\nLet's write our first test to demonstrate this function. We're going to set up\nnightwatch so that it launches the page, and clicks on the Login link in the\nnavbar. We'll take the following steps to do this:\n247\n\n\f1. We'll first call the url() function on browser to ask it to load a URL on\nthe page.\n2. We'll wait for the page to load for a certain amount of time.\n3. We'll find the Login link and click on it.\nAnd we'll set up assertions along the way. Let's get busy! We'll ask the\nbrowser to load the URL we set in our configuration file (for us, it's\nhttp://localhost:3000 )","metadata":{"loc":{"lines":{"from":7447,"to":7468}}}}],["284",{"pageContent":"module.exports = {\n\"get to login page\": browser => {\nbrowser\n// Load the page at the launch URL\n.url(browser.launchUrl)\n// wait for page to load\n.waitForElementVisible(\".navbar\", 1000)\n// click on the login link\n.click('a[href=\"/login\"]');\nbrowser.assert.urlContains(\"login\");\n},\n\"logging in\": browser => {},\n\"logging out\": browser => {},\nclose: browser => {}\n};\n\nThats it. Before we get too far ahead, let's run this test to make sure our test\nsetup works. We'll need to open 3 terminal windows here.\nIn the first terminal window, let's launch selenium. If you downloaded the\n.jar file, you can start this with the command:\n\njava -jar selenium-server-standalone-{VERSION}.jar\n\nIf you downloaded it through homebrew, you can use the selenium-server\ncommand:\n\n248\n\n\fselenium-server\n\nIn the second window, we'll need to launch our app. Remember, the browser\nwe're going to launch will actually hit our site, so we need an instance of it\nrunning. We can start our app up with the npm start comamnd:\n\nnpm start\n\n249","metadata":{"loc":{"lines":{"from":7470,"to":7506}}}}],["285",{"pageContent":"npm start\n\n249\n\n\fFinally, in the third and final terminal window, we'll run our tests using the\nnightwatch command.\n\nnightwatch\n\n250\n\n\fWhen we run the nightwatch command, we'll see a chrome window open up,\nvisit the site, and click on the login link automatically... (pretty cool, right?).\nAll of our tests pass at this point. Let's actually tell the browser to log a user\nin.\nSince the first step will run, the browser will already be on the login page. In\nthe second key of our tests, we'll want to take the following steps:\n1. We'll want to find the input for he user's email and set a value to a\nvalid email.\n2. We'll want to click the submit/login button\n3. We'll wait for the page to load (similar to how we did previously)\n4. We'll want to assert that the text of the page is equal to what we expect\nit to be.\n5. We'll set an assertion to make sure the URL is what we think it is.\nWriting this up in code is straight-forward too. Just like we did previously,\nlet's write the code with comments inline:","metadata":{"loc":{"lines":{"from":7506,"to":7531}}}}],["286",{"pageContent":"251\n\n\fmodule.exports = {\n\"get to login page\": browser => {\nbrowser\n// Load the page at the launch URL\n.url(browser.launchUrl)\n// wait for page to load\n.waitForElementVisible(\".navbar\", 1000)\n// click on the login link\n.click('a[href=\"/login\"]');\nbrowser.assert.urlContains(\"login\");\n},\n\"logging in\": browser => {\nbrowser\n// set the input email to a valid username / password\n.setValue(\"input[type=text]\", \"admin\")\n.setValue(\"input[type=password]\", \"secret\")\n// submit the form\n.click(\"input[type=submit]\")\n// wait for the page to load\n.waitForElementVisible(\".navbar\", 1000)\n// Get the text of the h1 tag\n.getText(\".home h1\", function(comp) {\nthis.assert.equal(comp.value, \"Welcome home!\");\n});\nbrowser.assert.urlContains(browser.launchUrl);\n},\n\"logging out\": browser => {},\nclose: browser => {}\n};\n\nRunning these tests again (in the third terminal window):\n\nnightwatch\n\n252","metadata":{"loc":{"lines":{"from":7533,"to":7569}}}}],["287",{"pageContent":"Running these tests again (in the third terminal window):\n\nnightwatch\n\n252\n\n\fWe can do a similar thing with the logging out step from our browser. To\nget a user to log out, we will:\n1. Find and click on the logout link\n2. We'll want to `wait for the content to load again\n3. We'll assert that t`he h1 tag contains the value we expect it to have\n4. And we'll make sure the page shows the Login button\nLet's implement this with comments inline:\n\n253","metadata":{"loc":{"lines":{"from":7569,"to":7583}}}}],["288",{"pageContent":"module.exports = {\n\"get to login page\": browser => {\nbrowser\n// Load the page at the launch URL\n.url(browser.launchUrl)\n// wait for page to load\n.waitForElementVisible(\".navbar\", 1000)\n// click on the login link\n.click('a[href=\"/login\"]');\nbrowser.assert.urlContains(\"login\");\n},\n\"logging in\": browser => {\nbrowser\n// set the input email to a valid username / password\n.setValue(\"input[type=text]\", \"admin\")\n.setValue(\"input[type=password]\", \"secret\")\n// submit the form\n.click(\"input[type=submit]\")\n// wait for the page to load\n.waitForElementVisible(\".navbar\", 1000)\n// Get the text of the h1 tag\n.getText(\".home h1\", function(comp) {\nthis.assert.equal(comp.value, \"Welcome home!\");\n});\nbrowser.assert.urlContains(browser.launchUrl);\n},\n\"logging out\": browser => {\nbrowser\n// Find and click on the logout link\n.click(\".logout\")\n// We'll wait for the next content to load\n.waitForElementVisible(\"h1\", 1000)\n// Get the text of the h1 tag\n.getText(\"h1\", function(res) {\nthis.assert.equal(res.value, \"You need to know the secret\");\n})","metadata":{"loc":{"lines":{"from":7585,"to":7620}}}}],["289",{"pageContent":"// We'll wait for the next content to load\n.waitForElementVisible(\"h1\", 1000)\n// Get the text of the h1 tag\n.getText(\"h1\", function(res) {\nthis.assert.equal(res.value, \"You need to know the secret\");\n})\n// Make sure the Login button shows now\n.waitForElementVisible('a[href=\"/login\"]', 1000);\n},\n254","metadata":{"loc":{"lines":{"from":7620,"to":7629}}}}],["290",{"pageContent":"close: browser => {}\n};\n\nAs of now, you may have noticed that your chrome browsers haven't been\nclosing when the tests have completed. This is because we haven't told\nselenium that we want the session to be complete. We can use the end()\ncommand on the browser object to close the connection. This is why we\nhave the last and final step called close .\n\n{\n// ...\n'close': (browser) => browser.end()\n}\n\nNow let's run the entire suite and make sure it passes again using the\nnightwatch command:\n\nnightwatch\n\n255","metadata":{"loc":{"lines":{"from":7631,"to":7650}}}}],["291",{"pageContent":"{\n// ...\n'close': (browser) => browser.end()\n}\n\nNow let's run the entire suite and make sure it passes again using the\nnightwatch command:\n\nnightwatch\n\n255\n\n\fOne final note, if you're interested in a deeper set of selenium tutorials,\ncheck out the free tutorials from guru99.com at\nhttps://www.guru99.com/selenium-tutorial.html\n(https://www.guru99.com/selenium-tutorial.html). They are pretty in-depth\nand well done (in our opinion).\nThat's it! We've made it and have covered 3 types of testing entirely, from\nlow-level up through faking a real browser instance. Now we have the tools\nto ensure our applications are ready for full deployment.\nBut wait, we don't actually have deployment figured out yet, do we? Stay\ntuned for tomorrow when we start getting our application deployed into the\ncloud.\n\n256\n\n\fDeployment Introduction\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-27/post.md)","metadata":{"loc":{"lines":{"from":7650,"to":7677}}}}],["292",{"pageContent":"256\n\n\fDeployment Introduction\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-27/post.md)\n\nToday, we'll explore the different pieces involved in deploying\nour application so the world can use our application out in the\nwild.\nWith our app all tested up through this point, it's time to get it up and live for\nthe world to see. The rest of this course will be dedicated to deploying our\napplication into production.\n\nProduction deployment\nWhen talking about deployment, we have a lot of different options:\nHosting\nDeployment environment configuration\nContinuous Integration (CI, for short)\nCost cycles, network bandwidth cost\nBundle size\nand more\nWe'll look at the different hosting options we have for deploying our react\napp tomorrow and look at a few different methods we have for deploying our\napplication up. Today we're going to focus on getting our app ready for\ndeployment.\n\n257","metadata":{"loc":{"lines":{"from":7677,"to":7702}}}}],["293",{"pageContent":"257\n\n\fEjection (from create-react-app )\nFirst things first... we're going to need to handle some customization in our\nweb application, so we'll need to run the npm run eject command in the root\nof our directory. This is a permanent action, which just means we'll be\nresponsible for handling customizations to our app structure for now on\n(without the help of our handy create-react-app ).\n\nThis is where I always say make a backup copy of your\napplication. We cannot go back from ejecting , but we can\nrevert to old code.\n\nWe can eject from the create-react-app structure by running the eject\ncommand provided by the generator:\n\nnpm run eject","metadata":{"loc":{"lines":{"from":7702,"to":7718}}}}],["294",{"pageContent":"We can eject from the create-react-app structure by running the eject\ncommand provided by the generator:\n\nnpm run eject\n\nAfter ejecting from the create-react-app structure, we'll see we get a lot of\nnew files in our application root in the config/ and scripts/ directories.\nThe npm run eject command created all of the files it uses internally and\nwrote them all out for us in our application.\nThe key method of the create-react-app generator is called webpack\n(https://webpack.github.io), which is a module bundler/builder.\n\nWebpack basics\nWebpack is a module bundler with a ginormous community of users, tons of\nplugins, is under active development, has a clever plugin system, is incredibly\nfast, supports hot-code reloading, and much much more.\n\n258","metadata":{"loc":{"lines":{"from":7718,"to":7735}}}}],["295",{"pageContent":"258\n\n\fAlthough we didn't really call it out before, we've been using webpack this\nentire time (under the guise of npm start ). Without webpack, we wouldn't\nhave have been able to just write import and expect our code to load. It\nworks like that because webpack \"sees\" the import keyword and knows we\nneed to have the code at the path accessible when the app is running.\nWebpack takes care of hot-reloading for us, nearly automatically, can load\nand pack many types of files into bundles, and it can split code in a logical\nmanner so as to support lazy-loading and shrink the initial download size for\nthe user.\nThis is meaningful for us as our apps grow larger and more complex, it's\nimportant to know how to manipulate our build tools.\nFor example, when we want to deploy to different environments... which we'll\nget to shortly. First, a tiny introduction to webpack, what it is and how it\nworks.","metadata":{"loc":{"lines":{"from":7735,"to":7750}}}}],["296",{"pageContent":"What it does with bundle.js\nLooking into the generated files when we ran npm start before we ejected\nthe app, we can see that it serves the browser two or more files. The first is\nthe index.html and the bundle.js . The webpack server takes care of\ninjecting the bundle.js into the index.html , even if we don't load our app in\nthe index.html file.\nThe bundle.js file is a giant file that contains all the JavaScript code our app\nneeds to run, including dependencies and our own files alike. Webpack has\nit's own method of packing files together, so it'll look kinda funny when\nlooking at the raw source.\nWebpack has performed some transformation on all the included JavaScript.\nNotably, it used Babel to transpile our ES6 code to an ES5-compatible format.\nIf you look at the comment header for app.js , it has a number, 254 :\n\n259\n\n\f/* 254 */\n/*!********************!*\\\n!*** ./src/app.js ***!\n\\********************/\n\nThe module itself is encapsulated inside of a function that looks like this:","metadata":{"loc":{"lines":{"from":7752,"to":7773}}}}],["297",{"pageContent":"259\n\n\f/* 254 */\n/*!********************!*\\\n!*** ./src/app.js ***!\n\\********************/\n\nThe module itself is encapsulated inside of a function that looks like this:\n\nfunction(module, exports, __webpack_require__) {\n// The chaotic `app.js` code here\n}\n\nEach module of our web app is encapsulated inside of a function with this\nsignature. Webpack has given each of our app's modules this function\ncontainer as well as a module ID (in the case of app.js , 254).\nBut \"module\" here is not limited to ES6 modules.\nRemember how we \"imported\" the makeRoutes() function in app.js , like this:\n\nimport makeRoutes from './routes'\n\nHere's what the variable declaration of makeRoutes looks like inside the chaos\nof the app.js Webpack module:\n\nvar _logo = __webpack_require__(/*! ./src/routes.js */ 255);\n\nThis looks quite strange, mostly due to the in-line comment that Webpack\nprovides for debugging purposes. Removing that comment:\n\nvar _logo = __webpack_require__(255);","metadata":{"loc":{"lines":{"from":7773,"to":7802}}}}],["298",{"pageContent":"This looks quite strange, mostly due to the in-line comment that Webpack\nprovides for debugging purposes. Removing that comment:\n\nvar _logo = __webpack_require__(255);\n\nInstead of an import statement, we have plain old ES5 code.\n\n260\n\n\fNow, search for ./src/routes.js in this file.\n\n/* 255 */\n/*!**********************!*\\\n!*** ./src/routes.js ***!\n\\**********************/\n\nNote that its module ID is 255 , the same integer passed to\n__webpack_require__ above.\nWebpack treats everything as a module, including image assets like logo.svg .\nWe can get an idea of what's going on by picking out a path in the mess of the\nlogo.svg module. Your path might be different, but it will look like this:\nstatic/media/logo.5d5d9eef.svg\n\nIf you open a new browser tab and plug in this address (your address will be\ndifferent... matching the name of the file webpack generated for you):\nhttp://localhost:3000/static/media/logo.5d5d9eef.svg","metadata":{"loc":{"lines":{"from":7802,"to":7827}}}}],["299",{"pageContent":"If you open a new browser tab and plug in this address (your address will be\ndifferent... matching the name of the file webpack generated for you):\nhttp://localhost:3000/static/media/logo.5d5d9eef.svg\n\nYou should get the React logo:\nSo Webpack created a Webpack module for logo.svg , one that refers to the\npath to the SVG on the Webpack development server. Because of this\nmodular paradigm, it was able to intelligently compile a statement like this:\n\nimport makeRoutes from './routes'\n\nInto this ES5 statement:\n\nvar _makeRoutes = __webpack_require__(255);\n\nWhat about our CSS assets? Yep, everything is a module in Webpack. Search\nfor the string ./src/app.css :\n261","metadata":{"loc":{"lines":{"from":7827,"to":7844}}}}],["300",{"pageContent":"Webpack's index.html didn't include any references to CSS. That's because\nWebpack is including our CSS here via bundle.js . When our app loads, this\ncryptic Webpack module function dumps the contents of app.css into style\ntags on the page.\nSo we know what is happening: Webpack has rolled up every conceivable\n\"module\" for our app into bundle.js . You might be asking: Why?\nThe first motivation is universal to JavaScript bundlers. Webpack has\nconverted all our ES6 modules into its own bespoke ES5-compatible module\nsyntax. As we briefly touched on, it's wrapped all of our JavaScript modules in\nspecial functions. It provides a module ID system to enable one module to\nreference another.\nWebpack, like other bundlers, consolidated all our JavaScript modules into a\nsingle file. It could keep JavaScript modules in separate files, but this requires\nsome more configuration than create-react-app provides out of the box.\nWebpack takes this module paradigm further than other bundlers, however.","metadata":{"loc":{"lines":{"from":7846,"to":7860}}}}],["301",{"pageContent":"some more configuration than create-react-app provides out of the box.\nWebpack takes this module paradigm further than other bundlers, however.\nAs we saw, it applies the same modular treatment to image assets, CSS, and\nnpm packages (like React and ReactDOM). This modular paradigm unleashes\na lot of power. We touch on aspects of that power throughout the rest of this\nchapter.","metadata":{"loc":{"lines":{"from":7860,"to":7865}}}}],["302",{"pageContent":"Complex, right?\nIt's okay if you don't understand that out of the box. Building and\nmaintaining webpack is a complex project with lots of moving parts and it\noften takes even the most experienced developers a while to \"get.\"\nWe'll walk through the different parts of our webpack configuration that\nwe'll be working with. If it feels overwhelming, just stick with us on the\nbasics here and the rest will follow.\n\n262\n\n\fWith our newfound knowledge of the inner workings of Webpack, let's turn\nour attention back to our app. We'll make some modifications to our webpack\nbuild tool to support multiple environment configurations.","metadata":{"loc":{"lines":{"from":7867,"to":7879}}}}],["303",{"pageContent":"Environment configuration\nWhen we're ready to deploy a new application, we have to think about a few\nthings that we wouldn't have to focus on when developing our application.\nFor instance, let's say we are requesting data from an API server... when\ndeveloping this application, it's likely that we are going to be running a\ndevelopment instance of the API server on our local machine (which would\nbe accessible through localhost ).\nWhen we deploy our application, we'll want to be requesting data from an\noff-site host, most likely not in the same location from where the code is\nbeing sent, so localhost just won't do.\nOne way we can handle our configuration management is by using .env files.\nThese .env files will contain different variables for our different\nenvironments, yet still provide a way for us to handle configuration in a sane\nway.\nUsually, we'll keep one .env file in the root to contain a global config that can\nbe overridden by configuration files on a per-environment basis.","metadata":{"loc":{"lines":{"from":7881,"to":7896}}}}],["304",{"pageContent":"way.\nUsually, we'll keep one .env file in the root to contain a global config that can\nbe overridden by configuration files on a per-environment basis.\nLet's install an npm package to help us with this configuration setup called\ndotenv :","metadata":{"loc":{"lines":{"from":7896,"to":7900}}}}],["305",{"pageContent":"npm install --save-dev dotenv\n\nThe dotenv (https://github.com/motdotla/dotenv) library helps us load\nenvironment variables into the ENV of our app in our environments.\n\n263\n\n\fIt's usually a good idea to add .env to our .gitignore file, so\nwe don't check in these settings.\nConventionally, it's a good idea to create an example version of the .env\nfile and check that into the repository. For instance, for our application\nwe can create a copy of the .env file called .env.example with the\nrequired variables.\nLater, another developer (or us, months from now) can use the\n.env.example file as a template for what the .env file should look like.\n\nThese .env files can include variables as though they are unix-style\nvariables. Let's create our global one with the APP_NAME set to 30days:\n\ntouch .env\necho \"APP_NAME=30days\" > .env","metadata":{"loc":{"lines":{"from":7902,"to":7922}}}}],["306",{"pageContent":"These .env files can include variables as though they are unix-style\nvariables. Let's create our global one with the APP_NAME set to 30days:\n\ntouch .env\necho \"APP_NAME=30days\" > .env\n\nLet's navigate to the exploded config/ directory where we'll see all of our\nbuild tool written out for us. We won't look at all of these files, but to get an\nunderstanding of what are doing, we'll start looking in\nconfig/webpack.config.dev.js .\nThis file shows all of the webpack configuration used to build our app. It\nincludes loaders, plugins, entry points, etc. For our current task, the line to\nlook for is in the plugins list where we define the DefinePlugin() :\n\n264","metadata":{"loc":{"lines":{"from":7922,"to":7936}}}}],["307",{"pageContent":"264\n\n\fmodule.exports = {\n// ...\nplugins: [\n// ...\n// Makes some environment variables available to the JS code, for\nexample:\n// if (process.env.NODE_ENV === 'production') { ... }. See\n`./env.js`.\n// It is absolutely essential that NODE_ENV is set to production\n// during a production build.\n// Otherwise React will be compiled in the very slow development\nmode.\nnew webpack.DefinePlugin(env.stringified),\n// ...\n]\n}\n\nThe webpack.DefinePlugin plugin takes an object with keys and values and\nfinds all the places in our code where we use the key and it replaces it with\nthe value.\nFor instance, if the env object there looks like:\n\n{\n'__NODE_ENV__': 'development'\n}\n\nWe can use the variable __NODE_ENV__ in our source and it will be replaced\nwith 'development', i.e.:\n\nclass SomeComponent extends React.Component {\nrender() {\nreturn (\n<div>Hello from {__NODE_ENV__}</div>\n)\n}\n}\n265","metadata":{"loc":{"lines":{"from":7936,"to":7974}}}}],["308",{"pageContent":"class SomeComponent extends React.Component {\nrender() {\nreturn (\n<div>Hello from {__NODE_ENV__}</div>\n)\n}\n}\n265\n\n\fThe result of the render() function would say \"Hello from development\".\nTo add our own variables to our app, we're going to use this env object and\nadd our own definitions to it. Scrolling back up to the top of the file, we'll see\nthat it's currently created and exported from the config/env.js file.\nLooking at the config/env.js file, we can see that it takes all the variables in\nour environment and adds the NODE_ENV to the environment as well as any\nvariables prefixed by REACT_APP_ .\n\n266","metadata":{"loc":{"lines":{"from":7974,"to":7991}}}}],["309",{"pageContent":"// ...\n// Grab NODE_ENV and REACT_APP_* environment variables and prepare\nthem to be\n// injected into the application via DefinePlugin in Webpack\nconfiguration.\nconst REACT_APP = /^REACT_APP_/i;\n// ...\nfunction getClientEnvironment(publicUrl) {\nconst raw = Object.keys(process.env)\n.filter(key => REACT_APP.test(key))\n.reduce(\n(env, key) => {\nenv[key] = process.env[key];\nreturn env;\n},\n{\n// Useful for determining whether we’re running in production\nmode.\n// Most importantly, it switches React into the correct mode.\nNODE_ENV: process.env.NODE_ENV || \"development\",\n// Useful for resolving the correct path to static assets in\n`public`.\n// For example, <img src={process.env.PUBLIC_URL +\n'/img/logo.png'} />.\n// This should only be used as an escape hatch. Normally you\nwould put\n// images into the `src` and `import` them in code to get\ntheir paths.\nPUBLIC_URL: publicUrl,\n}\n);\n// Stringify all values so we can feed into Webpack DefinePlugin\nconst stringified = {\n\"process.env\": Object.keys(raw).reduce((env, key) => {","metadata":{"loc":{"lines":{"from":7993,"to":8026}}}}],["310",{"pageContent":"their paths.\nPUBLIC_URL: publicUrl,\n}\n);\n// Stringify all values so we can feed into Webpack DefinePlugin\nconst stringified = {\n\"process.env\": Object.keys(raw).reduce((env, key) => {\nenv[key] = JSON.stringify(raw[key]);\nreturn env;\n}, {})\n};\nreturn { raw, stringified };\n}\n267","metadata":{"loc":{"lines":{"from":8026,"to":8039}}}}],["311",{"pageContent":"module.exports = getClientEnvironment;\n\nWe can skip all the complex part of that operation as we'll only need to\nmodify the second argument to the reduce function, in other words, we'll\nupdate the object:\n\n{\n// Useful for determining whether we’re running in production mode.\n// Most importantly, it switches React into the correct mode.\nNODE_ENV: process.env.NODE_ENV || \"development\",\n// Useful for resolving the correct path to static assets in\n`public`.\n// For example, <img src={process.env.PUBLIC_URL + '/img/logo.png'}\n/>.\n// This should only be used as an escape hatch. Normally you would\nput\n// images into the `src` and `import` them in code to get their\npaths.\nPUBLIC_URL: publicUrl,\n}\n\nThis object is the initial object of the reduce function. The\nreduce function merges all of the variables prefixed by\nREACT_APP_ into this object, so we'll always have the\nprocess.env.NODE_ENV replaced in our source.","metadata":{"loc":{"lines":{"from":8041,"to":8065}}}}],["312",{"pageContent":"Essentially what we'll do is:\n1. Load our default .env file\n2. Load any environment .env file\n3. Merge these two variables together as well as any default variables (such\nas the NODE_ENV )\n4. We'll create a new object with all of our environment variables and\nsanitize each value.\n268\n\n\f5. Update the initial object for the existing environment creator.\nLet's get busy. In order to load the .env file, we'll need to import the dotenv\npackage. We'll also import the path library from the standard node library\nand set up a few variables for paths.\nLet's update the config/env.js file\n\nvar REACT_APP = /^REACT_APP_/i;\nvar NODE_ENV = process.env.NODE_ENV || 'development';\nconst path = require('path'),\nresolve = path.resolve,\njoin = path.join;\nconst currentDir = resolve(__dirname);\nconst rootDir = join(currentDir, '..');\nconst dotenv = require('dotenv');","metadata":{"loc":{"lines":{"from":8067,"to":8089}}}}],["313",{"pageContent":"To load the global environment, we'll use the config() function exposed by\nthe dotenv library and pass it the path of the .env file loaded in the root\ndirectory. We'll also use the same function to look for a file in the config/\ndirectory with the name of NODE_ENV.config.env . Additionally, we don't want\neither one of these methods to error out, so we'll add the additional option of\nsilent: true so that if the file is not found, no exception will be thrown.\n\n// 1. Step one (loading the default .env file)\nconst globalDotEnv = dotenv.config({\npath: join(rootDir, '.env'),\nsilent: true\n});\n// 2. Load the environment config\nconst envDotEnv = dotenv.config({\npath: join(currentDir, NODE_ENV + `.config.env`),\nsilent: true\n});\n\n269\n\n\fNext, let's concatenate all these variables together as well as include our\nNODE_ENV option in this object. The Object.assign() method creates a new\nobject and merges each object from right to left. This way, the environment\nconfig variable","metadata":{"loc":{"lines":{"from":8091,"to":8114}}}}],["314",{"pageContent":"const allVars = Object.assign(\n{},\n{\nNODE_ENV: NODE_ENV\n},\nglobalDotEnv.parsed,\nenvDotEnv.parsed\n);\n\nWith our current setup, the allVars variable will look like:\n\n{\n'NODE_ENV': 'development',\n'APP_NAME': '30days'\n}\n\nNow we can add this allVars as an argument to the reduce function initial\nvalue called in the raw variable in the getClientEnvironment function. Let's\nupdate it to use this object:\n\n270","metadata":{"loc":{"lines":{"from":8116,"to":8136}}}}],["315",{"pageContent":"Now we can add this allVars as an argument to the reduce function initial\nvalue called in the raw variable in the getClientEnvironment function. Let's\nupdate it to use this object:\n\n270\n\n\ffunction getClientEnvironment(publicUrl) {\n// ...\nconst raw = Object.keys(process.env)\n.filter(key => REACT_APP.test(key))\n.reduce(\n(env, key) => {\nenv[key] = process.env[key];\nreturn env;\n},\n{\n// Useful for determining whether we’re running in production\nmode.\n// Most importantly, it switches React into the correct mode.\nNODE_ENV: process.env.NODE_ENV || \"development\",\n// Useful for resolving the correct path to static assets in\n`public`.\n// For example, <img src={process.env.PUBLIC_URL +\n'/img/logo.png'} />.\n// This should only be used as an escape hatch. Normally you\nwould put\n// images into the `src` and `import` them in code to get\ntheir paths.\nPUBLIC_URL: publicUrl,\n...allVars\n}\n);\n// ...\n}","metadata":{"loc":{"lines":{"from":8136,"to":8169}}}}],["316",{"pageContent":"Now, anywhere in our code we can use the variables we set in our .env files.\nSince we are making a request to an off-site server in our app, let's use our\nnew configuration options to update this host.\nLet's say by default we want the TIME_SERVER to be set to\nhttp://localhost:3001 , so that if we don't set the TIME_SERVER in an\nenvironment configuration, it will default to localhost. We can do this by\nadding the TIME_SERVER variable to the global .env file.\nLet's update the .env file so that it includes this time server:\n271\n\n\fAPP_NAME=30days\nTIME_SERVER='http://localhost:3001'\n\nNow, we've been developing in \"development\" with the server hosted on\nheroku. We can set our config/development.config.env file to set the\nTIME_SERVER variable, which will override the global one:\n\nTIME_SERVER='https://fullstacktime.herokuapp.com'","metadata":{"loc":{"lines":{"from":8171,"to":8188}}}}],["317",{"pageContent":"TIME_SERVER='https://fullstacktime.herokuapp.com'\n\nNow, when we run npm start , any occurrences of process.env.TIME_SERVER\nwill be replaced by which ever value takes precedence.\nLet's update our src/redux/actionCreators.js module to use the new server,\nrather than the hardcoded one we used previously.\n\n// ...\nconst host = process.env.TIME_SERVER;\nexport const fetchNewTime = (timezone = \"pst\", str = \"now\") => ({\ntype: types.FETCH_NEW_TIME,\npayload: new Date().toString(),\nmeta: {\ntype: \"api\",\nurl: host + \"/\" + timezone + \"/\" + str + \".json\"\n}\n});\n\nNow, for our production deployment, we'll use the heroku app, so let's create\na copy of the development.config.env file as production.config.env in the\nconfig/ directory:\n\ncp config/development.config.env config/production.config.env\n\nCustom middleware perconfiguration environment\n\n272\n\n\fconfiguration environment","metadata":{"loc":{"lines":{"from":8188,"to":8216}}}}],["318",{"pageContent":"cp config/development.config.env config/production.config.env\n\nCustom middleware perconfiguration environment\n\n272\n\n\fconfiguration environment\n\nWe used our custom logging redux middleware in our application. This is\nfantastic for working on our site in development, but we don't really want it\nto be active while in a production environment.\nLet's update our middleware configuration to only use the logging\nmiddleware when we are in development, rather than in all environments. In\nour project's src/redux/configureStore.js file, we loaded our middleware by\na simple array:\n\nlet middleware = [\nloggingMiddleware,\napiMiddleware\n];\nexport const configureStore = () => {\n// ...\nconst store = createStore(rootReducer, initialState,\napplyMiddleware(...middleware));\n// ...\n}\n\nNow that we have the process.env.NODE_ENV available to us in our files, we\ncan update the middleware array depending upon the environment we're\nrunning in. Let's update it to only add the logging if we are in the\ndevelopment environment:","metadata":{"loc":{"lines":{"from":8216,"to":8246}}}}],["319",{"pageContent":"// ...\nlet middleware = [apiMiddleware];\nif (\"development\" === process.env.NODE_ENV) {\nmiddleware.unshift(loggingMiddleware);\n}\n// ...\n\nNow when we run our application in development, we'll have the\nloggingMiddleware set, while in any other environment we've disabled it.\nToday was a long one, but tomorrow is an exciting day as we'll get the app up\nand running on a remote server.\n273\n\n\fGreat work today and see you tomorrow!\n\n274\n\n\fDeployment\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-28/post.md)\n\nToday, we'll look through some ready-to-go options so we can\nget our site up and running. By the end of today, you'll be able to\nshare a link to your running application.\nWe left off yesterday preparing for our first deployment of our application.\nWe're ready to deploy our application. Now the question is where and what\nare we going to deploy?\nLet's explore...","metadata":{"loc":{"lines":{"from":8248,"to":8274}}}}],["320",{"pageContent":"What\nWhile deploying a single page application has it's own intricasies, it's similar\nto deploying a non-single page application. What the end-user's browser\nrequests all need to be available for the browser to request. This means all\njavascript files, any custom fonts, images, svg, stylesheets, etc. that we use in\nour application need to be available on a publicly available server.\nWebpack takes care of building and packaging our entire application for what\nwe'll need to give the server to send to our clients. This includes any clientside tokens and our production configuration (which we put together\nyesterday).\n\n275","metadata":{"loc":{"lines":{"from":8276,"to":8286}}}}],["321",{"pageContent":"275\n\n\fThis means we only need to send the contents of the distribution directory\nwebpack put together. In our case, this directory is the build/ directory. We\ndon't need to send anything else in our project to a remote server.\nLet's use our build system to generate a list of production files we'll want to\nhost. We can run the npm run build command to generate these files in the\nbuild/ directory:\n\nnpm run build\n\nWhere\nThese days we have many options for hosting client-side applications. We'll\nlook at a few options for hosting our application today. Each of the following\nhosting services have their benefits and drawbacks, which we'll briefly\ndiscuss before we actually make a deployment.\nThere are two possible ways for us to deploy our application. If we are\nworking with a back-end application, we can use the back-end server to host\nour public application files. For instance, if we were building a rails\n276","metadata":{"loc":{"lines":{"from":8286,"to":8305}}}}],["322",{"pageContent":"application, we can send the client-side application directly to the public/\nfolder of the rails application.\nThis has the benefit of providing additional security in our application as we\ncan verify a request from a client-side application made to the backend to\nhave been generated by the server-side code. One drawback, however is that\nit can hog network bandwidth to send static files and potentially suck up\nresources from other clients.\nIn this section, we'll work on hosting our client-side only application, which\nis the second way we can deploy our application. This means we can run/use\na server which is specifically designed for hosting static files separate from\nthe back-end server.\nWe'll focus on the second method where we are using other services to\ndeploy our client-side application. That is, we'll skip building a back-end and\nupload our static files to one (or more) of the (non-exhaustive) list of hosting\nservices.\nsurge.sh (https://surge.sh/)\ngithub pages (https://pages.github.com/)","metadata":{"loc":{"lines":{"from":8307,"to":8323}}}}],["323",{"pageContent":"upload our static files to one (or more) of the (non-exhaustive) list of hosting\nservices.\nsurge.sh (https://surge.sh/)\ngithub pages (https://pages.github.com/)\nheroku (https://www.heroku.com/)\nAWS S3 (https://aws.amazon.com/s3/)\nForge (https://getforge.com/)\nBitBalloon (https://www.bitballoon.com/)\nPancake (https://www.pancake.io/)\n... More\nWe'll explore a few of these options together.","metadata":{"loc":{"lines":{"from":8323,"to":8333}}}}],["324",{"pageContent":"surge.sh\n\n277\n\n\fsurge.sh (https://surge.sh/) is arguably one of the easiest hosting providers\nto host our static site with. They provide a way for us to easily and repeatable\nmethods for hosting our sites.\nLet's deploy our application to surge. First, we'll need to install the surge\ncommand-line tool. We'll use npm , like so:\n\nnpm install --global surge\n\nWith the surge tool installed, we can run surge in our local directory and\npoint it to the build/ directory to tell it to upload the generated files in the\nbuild/ directory.\n\nsurge -p build\n\nThe surge tool will run and it will upload all of our files to a domain specified\nby the output of the tool. In the case of the previous run, this uploads our\nfiles to the url of hateful-impulse.surge.sh (http://hateful-impulse.surge.sh/)\n(or the SSL version at https://hateful-impulse.surge.sh/ (https://hatefulimpulse.surge.sh/))\n278\n\n\fFor more information on surge , check out their documentation at\nhttps://surge.sh/help/ (https://surge.sh/help/).\n\nGithub pages","metadata":{"loc":{"lines":{"from":8335,"to":8362}}}}],["325",{"pageContent":"For more information on surge , check out their documentation at\nhttps://surge.sh/help/ (https://surge.sh/help/).\n\nGithub pages\n\n279\n\n\fgithub pages (https://pages.github.com/) is another easy service to deploy\nour static files to. It's dependent upon using github to host our git files, but is\nanother easy-to-use hosting environment for single page applications.\nWe'll need to start by creating our github pages repository on github. With an\nactive account, we can visit the github.com/new (https://github.com/new)\nsite and create a repository.\n\nWith this repo, it will redirect us to the repo url. Let's click on the clone or\ndownload button and find the github git url. Let's copy and paste this to our\nclipboard and head to our terminal.\n\n280\n\n\fIn our terminal, let's add this as a remote origin for our git repo.\nSince we haven't created this as a git repo yet, let's initialize the git repo:\n\ngit init\ngit add -A .\ngit commit -am \"Initial commit\"","metadata":{"loc":{"lines":{"from":8362,"to":8387}}}}],["326",{"pageContent":"git init\ngit add -A .\ngit commit -am \"Initial commit\"\n\nIn the root directory of our application, let's add the remote with the\nfollowing command:\n\ngit remote add github [your git url here]\n# From the demo, this will be:\n# git remote add origin git@github.com:auser/30-days-of-react-demo.git\n\nNext, we'll need to move to a branch called gh-pages as github deploys from\nthis branch. We can easily do this by checking out in a new branch using git.\nLet's also run the generator and tell git that the build/ directory should be\nconsidered the root of our app:\n\n281\n\n\fnpm run build\ngit checkout -B gh-pages\ngit add -f build\ngit commit -am \"Rebuild website\"\ngit filter-branch -f --prune-empty --subdirectory-filter build\ngit checkout -\n\nSince github pages does not serve directly from the root, but instead the\nbuild folder, we'll need to add a configuration to our package.json by setting\nthe homepage key to the package.json file with our github url. Let's open the\npackage.json file and add the \"homepage\" key:","metadata":{"loc":{"lines":{"from":8387,"to":8415}}}}],["327",{"pageContent":"{\n\"name\": \"30days\",\n\"version\": \"0.0.1\",\n\"private\": true,\n\"homepage\": \"http://auser.github.io/30-days-of-react-demo\n(http://auser.github.io/30-days-of-react-demo)\",\n// ...\n}\n\n282\n\n\fHint\nWe can modify json files by using the jq (https://stedolan.github.io/jq/)\ntool. If you don't have this installed, get it... get it now... It's invaluable\nTo change the package.json file from the command-line, we can use jq,\nlike so:\n\njq '.homepage = \\\n\"http://auser.github.io/30-days-of-react-demo\n(http://auser.github.io/30-days-of-react-demo)\"' \\\n> package.json\n\nWith our pages built, we can generate our application using npm run build\nand push to github from our local build/ directory.\n\ngit push -f github gh-pages\n\nNow we can visit our site at the repo pages url. For instance, the demo site is:\nhttps://auser.github.io/30-days-of-react-demo (https://auser.github.io/30days-of-react-demo/#).\n\n283","metadata":{"loc":{"lines":{"from":8417,"to":8447}}}}],["328",{"pageContent":"Now we can visit our site at the repo pages url. For instance, the demo site is:\nhttps://auser.github.io/30-days-of-react-demo (https://auser.github.io/30days-of-react-demo/#).\n\n283\n\n\fFuture deployments\nWe'll need to add this work to a deployment script, so every time we want\nto release a new version of the site. We'll do more of this tomorrow. To\nrelease to github, we'll have to use the following script:\n\n#!/usr/bin/env bash\ngit checkout -B gh-pages\ngit add -f build\ngit commit -am \"Rebuild website\"\ngit filter-branch -f --prune-empty --subdirectory-filter build\ngit push -f origin gh-pages\ngit checkout -\n\nFor more information on github pages, check out their documentation at\nhttps://help.github.com/categories/github-pages-basics/\n(https://help.github.com/categories/github-pages-basics/).\n\nHeroku\n\n284","metadata":{"loc":{"lines":{"from":8447,"to":8471}}}}],["329",{"pageContent":"For more information on github pages, check out their documentation at\nhttps://help.github.com/categories/github-pages-basics/\n(https://help.github.com/categories/github-pages-basics/).\n\nHeroku\n\n284\n\n\fHeroku (https://www.heroku.com/) is a very cool hosting service that allows\nus to host both static and non-static websites. We might want to deploy a\nstatic site to heroku as we may want to move to a dynamic backend at some\npoint, are already comfortable with deploying to heroku, etc.\nTo deploy our site to heroku, we'll need an account. We can get one by\nvisiting https://signup.heroku.com/ (https://signup.heroku.com/) to sign up\nfor one.\nWe'll also need the heroku toolbet\n(https://devcenter.heroku.com/articles/heroku-command-line) as we'll be\nusing the heroku command-line tool.\nFinally, we'll need to run heroku login to set up credentials for our\napplication:\n\nheroku login","metadata":{"loc":{"lines":{"from":8471,"to":8492}}}}],["330",{"pageContent":"heroku login\n\nNext, we'll need to tell the heroku command-line that we have a heroku app.\nWe can do this by calling heroku apps:create from the command-line in our\nproject root:\n285\n\n\fheroku apps:create\n# or with a name\nheroku apps:create thirty-days-of-react-demo\n\nHeroku knows how to run our application thanks to buildpacks\n(https://devcenter.heroku.com/articles/buildpacks). We'll need to tell\nheroku we have a static-file buildpack so it knows to serve our application as\na static file/spa.\nWe'll need to install the static-files plugin for heroku. This can be easiy install\nusing the heroku tool:\n\nheroku plugins:install heroku-cli-static\n\n286\n\n\fWe can add the static file buildpack with the following command:\n\nheroku buildpacks:set https://github.com/hone/heroku-buildpack-static\n(https://github.com/hone/heroku-buildpack-static)\n\nFor any configuration updates, we'll need to run the static:init command\nfrom heroku to generate the necessary static.json file:\n\nheroku static:init\n\n287","metadata":{"loc":{"lines":{"from":8492,"to":8524}}}}],["331",{"pageContent":"For any configuration updates, we'll need to run the static:init command\nfrom heroku to generate the necessary static.json file:\n\nheroku static:init\n\n287\n\n\fNow we can deploy our static site to heroku using the git workflow:\n\ngit push heroku master\n# or from a branch, such as the heroku branch\ngit push heroku heroku:master\n\nWe've deployed to only three of the hosting providers from the list above.\nThere are many more options for deploying our application, however this is a\npretty good start.\nWhen we deploy our application, we will want to make sure everything is\nworking before we actually send out the application to the world. Tomorrow\nwe'll work on integrating a Continuous integration (CI, for short) server to\nrun our tests before we deploy.\n\n288\n\n\fContinuous Integration\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-29/post.md)","metadata":{"loc":{"lines":{"from":8524,"to":8548}}}}],["332",{"pageContent":"288\n\n\fContinuous Integration\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-29/post.md)\n\nToday we'll look through some continuous integration solutions\navailable for us to run tests against as well as implement one to\ntest our application in the cloud.\nWe've deployed our application to the \"cloud\", now we want to make sure\neverything runs as we expect it. We've started a test suite, but now we want\nto make sure it passes completely before we deploy.\nWe could set a step-by-step procedure for a developer to follow to make sure\nwe run our tests before we deploy manually, but sometimes this can get in\nthe way of deployment, especially under high-pressure deadlines in the\nmiddle of the night. There are better methods.","metadata":{"loc":{"lines":{"from":8548,"to":8562}}}}],["333",{"pageContent":"Testing then deployment\nThe core idea is that we want to deploy our application only after all of our\ntests have run and passed (sometimes known as \"going green\"). There are\nmany ways we can do this. Mentioned above, we can handle it through\nhumans, but that can become tedious and we're pretty good at forgetting\nthings... what was I saying again?\nLet's look at some better ways. One of the ways we can handle it is through a\ndeployment script that only succeeds if all of our tests pass. This is the\neasiest, but needs to be replicated across a team of developers.\n289","metadata":{"loc":{"lines":{"from":8564,"to":8573}}}}],["334",{"pageContent":"Another method is to push our code to a continuous integration server\nwhose only responsibility is to run our tests and deploy our application if and\nonly if the tests pass.\nJust like hosting services, we have many options for running continuous\nintegration servers. The following is a short list of some of the popular CI\nservers available:\ntravis ci (https://travis-ci.org/)\ncircle ci (https://circleci.com)\ncodeship (https://codeship.io)\njenkins (https://jenkins.io)\nAWS EC2 (https://aws.amazon.com/ec2/)\nLet's look at a few ways of handling this process.\n\nCustom build script\nWithout involving any extra servers, we can write a script to execute our\ntests before we deploy.\nLet's create a script that actually does do the deployment process first. In our\ncase, let's take the surge.sh example from yesterday. Let's add one more\nscript we'll call deploy.sh in our scripts/ directory:\n\ntouch scripts/deploy.sh\nchmod u+x scripts/deploy.sh","metadata":{"loc":{"lines":{"from":8575,"to":8596}}}}],["335",{"pageContent":"touch scripts/deploy.sh\nchmod u+x scripts/deploy.sh\n\nIn here, let's add the surge deploy script (changing the names to your domain\nname, of course):\n\n#!/usr/bin/env bash\nsurge -p build --domain hateful-impulse.surge.sh\n\nLet's write the release script next. To execute it, let's add the script to the\npackage.json scripts object:\n\n290\n\n\f{\n// ...\n\"scripts\": {\n\"start\": \"node ./scripts/start.js\",\n\"build\": \"node ./scripts/build.js\",\n\"release\": \"node ./scripts/release.js\",\n\"test\": \"node ./scripts/test.js\"\n},\n}\n\nNow let's create the scripts/release.js file. From the root directory in our\nterminal, let's execute the following command:\n\ntouch scripts/release.js","metadata":{"loc":{"lines":{"from":8596,"to":8623}}}}],["336",{"pageContent":"Now let's create the scripts/release.js file. From the root directory in our\nterminal, let's execute the following command:\n\ntouch scripts/release.js\n\nInside this file, we'll want to run a few command-line scripts, first our build\nstep, then we'll want to run our tests, and finally we'll run the deploy script, if\neverything else succeeds first.\nIn a node file, we'll first set the NODE_ENV to be test for our build tooling.\nWe'll also include a script to run a command from the command-line from\nwithin the node script and store all the output to an array.\n\n291","metadata":{"loc":{"lines":{"from":8623,"to":8635}}}}],["337",{"pageContent":"291\n\n\fprocess.env.NODE_ENV = \"test\";\nprocess.env.CI = true;\nvar chalk = require(\"chalk\");\nconst exec = require(\"child_process\").exec;\nvar output = [];\nfunction runCmd(cmd) {\nreturn new Promise((resolve, reject) => {\nconst testProcess = exec(cmd, { stdio: [0, 1, 2] });\ntestProcess.stdout.on(\"data\", msg => output.push(msg));\ntestProcess.stderr.on(\"data\", msg => output.push(msg));\ntestProcess.on(\"close\", code => (code === 0 ? resolve() :\nreject()));\n});\n}\n\nWhen called, the runCmd() function will return a promise that is resolved\nwhen the command exits successfully and will reject if there is an error.\nOur release script will need to be able to do the following tasks:\n1. build\n2. test\n3. deploy\n4. report any errors\nMentally, we can think of this pipeline as:\n\nbuild()\n.then(runTests)\n.then(deploy)\n.catch(error);\n\nLet's build these functions which will use our runCmd function we wrote\nearlier:\n292","metadata":{"loc":{"lines":{"from":8635,"to":8668}}}}],["338",{"pageContent":"build()\n.then(runTests)\n.then(deploy)\n.catch(error);\n\nLet's build these functions which will use our runCmd function we wrote\nearlier:\n292\n\n\ffunction build() {\nconsole.log(chalk.cyan(\"Building app\"));\nreturn runCmd(\"npm run build\");\n}\nfunction runTests() {\nconsole.log(chalk.cyan(\"Running tests...\"));\nreturn runCmd(\"npm test\");\n}\nfunction deploy() {\nconsole.log(chalk.green(\"Deploying...\"));\nreturn runCmd(`sh -c \"${__dirname}/deploy.sh\"`);\n}\nfunction error() {\nconsole.log(chalk.red(\"There was an error\"));\noutput.forEach(msg => process.stdout.write(msg));\n}\nbuild()\n.then(runTests)\n.then(deploy)\n.catch(error);\n\nWith our scripts/release.js file complete, let's execute our npm run\nrelease command to make sure it deploys:\n\nnpm run release\n\nWith all our tests passing, our updated application will be deployed\nsuccessfully!\n\n293","metadata":{"loc":{"lines":{"from":8668,"to":8706}}}}],["339",{"pageContent":"npm run release\n\nWith all our tests passing, our updated application will be deployed\nsuccessfully!\n\n293\n\n\fIf any of our tests fail, we'll get all the output of our command, including the\nfailure errors. Let's update one of our tests to make them fail purposefully to\ntest the script.\nI'll update the src/components/Nav/__tests__/Navbar-test.js file to change\nthe first test to fail:\n\n// ...\nit(\"wraps content in a div with .navbar class\", () => {\nwrapper = shallow(<Navbar />);\nexpect(wrapper.find(\".navbars\").length).toEqual(1);\n});\n\nLet's rerun the release script and watch it fail and not run the deploy script:\n\nnpm run release\n\n294\n\n\fAs we see, we'll get the output of the failing test in our logs, so we can fix the\nbug and then rerelease our application again by running the npm run release\nscript again.","metadata":{"loc":{"lines":{"from":8706,"to":8733}}}}],["340",{"pageContent":"npm run release\n\n294\n\n\fAs we see, we'll get the output of the failing test in our logs, so we can fix the\nbug and then rerelease our application again by running the npm run release\nscript again.\n\nTravis CI\nTravis ci (https://travis-ci.org/) is a hosted continuous integration\nenvironment and is pretty easy to set up. Since we've pushed our container\nto github, let's continue down this track and set up travis with our github\naccount.\nHead to travis-ci.org (https://travis-ci.org/) and sign up there.\n\n295\n\n\fOnce you're signed up, click on the + button and find your repository:\n\nFrom the project screen, click on the big 'activate repo' button.\n\n296","metadata":{"loc":{"lines":{"from":8733,"to":8754}}}}],["341",{"pageContent":"295\n\n\fOnce you're signed up, click on the + button and find your repository:\n\nFrom the project screen, click on the big 'activate repo' button.\n\n296\n\n\fTo allow Travis CI to automatically log in for us during deployment, we need\nto add SURGE_LOGIN and SURGE_TOKEN environment variables. Open the More\nOptions menu and click settings.\nUnder environment variables, create a variable called SURGE_LOGIN and set it\nto the email address you use with Surge. Next, add another variable called\nSURGE_TOKEN and set it to your Surge token.\n\nYou can view your surge token by typing surge token in your\nterminal. Since we're using surge for depolyment, we should\nalsoadd it to our devDependencies in package.json . Run npm\ninstall surge --save-dev to add it\n\nNow we need to configure travis to do what we want, which is run our test\nscripts and then deploy our app. To configure travis, we'll need to create a\n.travis.yml file in the root of our app.\n\ntouch .travis.yml\n297","metadata":{"loc":{"lines":{"from":8754,"to":8779}}}}],["342",{"pageContent":"touch .travis.yml\n297\n\n\fLet's add the following content to set the language to node with the node\nversion of 10.15.0:\n\nlanguage: node_js\nnode_js:\n- \"10.15.0\"\n\nNow all we need to do is add this file .travis.yml to git and push the repo\nchanges to github.\n\ngit add .travis.yml\ngit commit -am \"Added travis-ci configuration file\"\ngit push github master\n\nThat's it. Now travis will execute our tests based on the default script of npm\ntest .\n\nNow, we'll want travis to actually deploy our app for us. Since we already have\na scripts/deploy.sh script that will deploy our app, we can use this to\ndeploy from travis.\n298\n\n\fTo tell travis to run our deploy.sh script after we deploy, we will need to add\nthe deploy key to our .travis.yml file. We also need to build our app before\ndeploy, hence the before_deploy . Let's update the yml config to tell it to run\nour deploy script:","metadata":{"loc":{"lines":{"from":8779,"to":8807}}}}],["343",{"pageContent":"language: node_js\nnode_js:\n- \"10.15.0\"\nbefore_deploy:\n- npm run build\ndeploy:\nprovider: script\nskip_cleanup: true\nscript: sh scripts/deploy.sh\non:\nbranch: master\n\nThe next time we push, travis will take over and push up to surge (or\nwherever the scripts/deploy.sh scripts will tell it to deploy).\nParticulars for authentication. To deploy to github pages, we'll need to add a\ntoken to the script. The gist at\nhttps://gist.github.com/domenic/ec8b0fc8ab45f39403dd\n(https://gist.github.com/domenic/ec8b0fc8ab45f39403dd) is a great\nresource to follow for deploying to github pages.\n\nOther methods\nThere are a lot of other options we have to run our tests before we deploy.\nThis is just a getting started guide to get our application up.\n\n299","metadata":{"loc":{"lines":{"from":8809,"to":8833}}}}],["344",{"pageContent":"Other methods\nThere are a lot of other options we have to run our tests before we deploy.\nThis is just a getting started guide to get our application up.\n\n299\n\n\fThe Travis CI service is fantastic for open-source projects,\nhowever to use it in a private project, we'll need to create a\nbillable account.\nAn open-source CI service called Jenkins (https://jenkins.io) which can\ntake a bit of work to setup (although it's getting a lot easier\n(https://jenkins.io/projects/blueocean/)).\n\nCongrats! We have our application up and running, complete with testing and\nall.\nSee you tomorrow for our last day!\n\n300\n\n\fWrap-up and More Resources\n Edit this page on Github (https://github.com/fullstackreact/30-days-of-react/blob/master/day-30/post.md)","metadata":{"loc":{"lines":{"from":8833,"to":8853}}}}],["345",{"pageContent":"We've made it! Day 30. Congrats! Now you have enough\ninformation to write some very complex applications, integrated\nwith data, styled to perfection, tested and deployed.\nWelcome to the final day! Congrats! You've made it!\nThe final component of our trip through React-land is a call to get involved.\nThe React community is active, growing, and friendly.\nCheck out the community projects on Github at: https://github.com/reactjs\n(https://github.com/reactjs)\nWe've covered a lot of material in the past 30 days. The high-level topics we\ndiscussed in our first 30 days:\n1. JSX and what it is, from the ground up.\n2. Building components a. Static b. Data-driven components c. Stateful and\nstateless components d. Pure components e. The inherent tree-based\nstructure of the virtual DOM\n3. The React component lifecycle\n4. How to build reusable and self-documenting components\n5. How to make our components stylish using native React proptypes as\nwell as third party libraries\n6. Adding interaction to our components","metadata":{"loc":{"lines":{"from":8855,"to":8873}}}}],["346",{"pageContent":"4. How to build reusable and self-documenting components\n5. How to make our components stylish using native React proptypes as\nwell as third party libraries\n6. Adding interaction to our components\n7. How to use create-react-app to bootstrap our apps\n8. How to integrate data from an API server, including a look at promises\n301","metadata":{"loc":{"lines":{"from":8873,"to":8879}}}}],["347",{"pageContent":"9. We worked through the Flux architecture\n10. Integrated Redux in our application, including how middleware works\n11. We integrated testing strategies in our app a. Unit testing b. End-to-end\ntesting c. Functional testing\n12. We discussed deployment and extending our application to support\nmulti-environment deployments\n13. We added continuous integration in our deployment chain.\n14. Client-side routing","metadata":{"loc":{"lines":{"from":8881,"to":8888}}}}],["348",{"pageContent":"There is so much more!\nAlthough we covered a lot of topics in our first 30 days, there is so much\nmore! How do we know? We wrote a book (https://www.fullstackreact.com)!\nInterested in reading more and going deeper with React? Definitely check it\nout. Not only do we cover in-depth the topics we briefly introduced in our\nfirst 30 days, we go into a ton of other content, including (but not limited to):\nUsing graphql and how to build a GraphQL server\nRelay and React\nHow to use React to build a React Native application\nHow to extend React Native to use our own custom modules\nAn in-depth, much more comprehensive review of testing, from unit\ntests through view tests\nA deep look into components, from an internals perspective\nAdvanced routing and dealing with production routing\nForms forms forms! We cover form validations, from basic form inputs\nthrough validating and integrating with Redux\nAnd much much much more.\nJust check out the book page at www.fullstackreact.com","metadata":{"loc":{"lines":{"from":8890,"to":8907}}}}],["349",{"pageContent":"Forms forms forms! We cover form validations, from basic form inputs\nthrough validating and integrating with Redux\nAnd much much much more.\nJust check out the book page at www.fullstackreact.com\n(https://www.fullstackreact.com) for more details.\nCongrats on making it to day 30! Time to celebrate!","metadata":{"loc":{"lines":{"from":8907,"to":8912}}}}],["350",{"pageContent":"302\n\n\f303","metadata":{"loc":{"lines":{"from":8914,"to":8916}}}}]]